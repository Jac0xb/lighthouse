{"version":3,"sources":["../../env-shim.ts","../../src/generated/errors/lighthouse.ts","../../src/generated/instructions/assertAccountData.ts","../../src/generated/shared/index.ts","../../src/generated/types/accountDeltaAssertion.ts","../../src/generated/types/accountInfoAssertion.ts","../../src/generated/types/accountInfoDeltaAssertion.ts","../../src/generated/types/accountInfoField.ts","../../src/generated/types/assertionResult.ts","../../src/generated/types/byteSliceOperator.ts","../../src/generated/types/clockField.ts","../../src/generated/types/dataValue.ts","../../src/generated/types/dataValueAssertion.ts","../../src/generated/types/dataValueDeltaAssertion.ts","../../src/generated/types/equatableOperator.ts","../../src/generated/types/integerOperator.ts","../../src/generated/types/knownProgram.ts","../../src/generated/types/logLevel.ts","../../src/generated/types/merkleTreeAssertion.ts","../../src/generated/types/metaAssertion.ts","../../src/generated/types/mintAccountAssertion.ts","../../src/generated/types/stakeAccountAssertion.ts","../../src/generated/types/stakeAssertion.ts","../../src/generated/types/stakeStateType.ts","../../src/generated/types/sysvarClockAssertion.ts","../../src/generated/types/tokenAccountAssertion.ts","../../src/generated/types/upgradableBufferAssertion.ts","../../src/generated/types/upgradeableLoaderStateAssertion.ts","../../src/generated/types/upgradeableLoaderStateType.ts","../../src/generated/types/upgradeableProgramAssertion.ts","../../src/generated/types/upgradeableProgramDataAssertion.ts","../../src/generated/types/writeType.ts","../../src/generated/instructions/assertAccountDelta.ts","../../src/generated/instructions/assertAccountInfo.ts","../../src/generated/instructions/assertAccountInfoMulti.ts","../../src/generated/instructions/assertMerkleTreeAccount.ts","../../src/generated/instructions/assertMintAccount.ts","../../src/generated/instructions/assertMintAccountMulti.ts","../../src/generated/instructions/assertStakeAccount.ts","../../src/generated/instructions/assertStakeAccountMulti.ts","../../src/generated/instructions/assertSysvarClock.ts","../../src/generated/instructions/assertTokenAccount.ts","../../src/generated/instructions/assertTokenAccountMulti.ts","../../src/generated/instructions/assertUpgradeableLoaderAccount.ts","../../src/generated/instructions/assertUpgradeableLoaderAccountMulti.ts","../../src/generated/instructions/memoryClose.ts","../../src/generated/instructions/memoryWrite.ts","../../src/generated/pdas/memory.ts","../../src/generated/programs/lighthouse.ts"],"names":["LighthouseProgramErrorCode","combineCodec","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","getU8Decoder","getU8Encoder","AccountRole","getDataEnumDecoder","getDataEnumEncoder","AccountInfoField","getAddressDecoder","getAddressEncoder","getBooleanDecoder","getBooleanEncoder","getBytesDecoder","getBytesEncoder","getI128Decoder","getI128Encoder","getOptionDecoder","getOptionEncoder","getU64Decoder","getU64Encoder","getScalarEnumDecoder","getScalarEnumEncoder","ByteSliceOperator","ClockField","getI16Decoder","getI16Encoder","getI32Decoder","getI32Encoder","getI64Decoder","getI64Encoder","getI8Decoder","getI8Encoder","getTupleDecoder","getTupleEncoder","getU128Decoder","getU128Encoder","getU32Decoder","getU32Encoder","EquatableOperator","IntegerOperator","KnownProgram","LogLevel","StakeStateType","UpgradeableLoaderStateType","mapEncoder","getArrayDecoder","getArrayEncoder","LighthouseInstruction"],"mappings":"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","sourcesContent":["// Clever obfuscation to prevent the build system from inlining the value of `NODE_ENV`\nexport const __DEV__ = /* @__PURE__ */ (() =>\n  (process as any)['en' + 'v'].NODE_ENV === 'development')();\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nexport const enum LighthouseProgramErrorCode {\n  /** InvalidInstructionData: Invalid instruction */\n  INVALID_INSTRUCTION_DATA = 0x1770, // 6000\n  /** AssertionFailed: AssertionFailed */\n  ASSERTION_FAILED = 0x1771, // 6001\n  /** NotEnoughAccounts: NotEnoughAccounts */\n  NOT_ENOUGH_ACCOUNTS = 0x1772, // 6002\n  /** BumpNotFound: BumpNotFound */\n  BUMP_NOT_FOUND = 0x1773, // 6003\n  /** AccountBorrowFailed: AccountBorrowFailed */\n  ACCOUNT_BORROW_FAILED = 0x1774, // 6004\n  /** RangeOutOfBounds: RangeOutOfBounds */\n  RANGE_OUT_OF_BOUNDS = 0x1775, // 6005\n  /** IndexOutOfBounds: IndexOutOfBounds */\n  INDEX_OUT_OF_BOUNDS = 0x1776, // 6006\n  /** FailedToDeserialize: FailedToDeserialize */\n  FAILED_TO_DESERIALIZE = 0x1777, // 6007\n  /** FailedToSerialize: FailedToSerialize */\n  FAILED_TO_SERIALIZE = 0x1778, // 6008\n  /** AccountOwnerMismatch: AccountOwnerMismatch */\n  ACCOUNT_OWNER_MISMATCH = 0x1779, // 6009\n  /** AccountKeyMismatch: AccountKeyMismatch */\n  ACCOUNT_KEY_MISMATCH = 0x177a, // 6010\n  /** AccountNotInitialized: AccountNotInitialized */\n  ACCOUNT_NOT_INITIALIZED = 0x177b, // 6011\n  /** AccountOwnerValidationFailed: AccountOwnerValidationFailed */\n  ACCOUNT_OWNER_VALIDATION_FAILED = 0x177c, // 6012\n  /** AccountFundedValidationFailed: AccountFundedValidationFailed */\n  ACCOUNT_FUNDED_VALIDATION_FAILED = 0x177d, // 6013\n  /** AccountDiscriminatorValidationFailed: AccountDiscriminatorValidationFailed */\n  ACCOUNT_DISCRIMINATOR_VALIDATION_FAILED = 0x177e, // 6014\n  /** AccountValidationFailed: AccountValidaitonFailed */\n  ACCOUNT_VALIDATION_FAILED = 0x177f, // 6015\n  /** CrossProgramInvokeViolation: CrossProgramInvokeViolation */\n  CROSS_PROGRAM_INVOKE_VIOLATION = 0x1780, // 6016\n}\n\nexport class LighthouseProgramError extends Error {\n  override readonly name = 'LighthouseProgramError';\n\n  readonly code: LighthouseProgramErrorCode;\n\n  readonly cause: Error | undefined;\n\n  constructor(\n    code: LighthouseProgramErrorCode,\n    name: string,\n    message: string,\n    cause?: Error\n  ) {\n    super(`${name} (${code}): ${message}`);\n    this.code = code;\n    this.cause = cause;\n  }\n}\n\nlet lighthouseProgramErrorCodeMap:\n  | Record<LighthouseProgramErrorCode, [string, string]>\n  | undefined;\nif (__DEV__) {\n  lighthouseProgramErrorCodeMap = {\n    [LighthouseProgramErrorCode.INVALID_INSTRUCTION_DATA]: [\n      'InvalidInstructionData',\n      `Invalid instruction`,\n    ],\n    [LighthouseProgramErrorCode.ASSERTION_FAILED]: [\n      'AssertionFailed',\n      `AssertionFailed`,\n    ],\n    [LighthouseProgramErrorCode.NOT_ENOUGH_ACCOUNTS]: [\n      'NotEnoughAccounts',\n      `NotEnoughAccounts`,\n    ],\n    [LighthouseProgramErrorCode.BUMP_NOT_FOUND]: [\n      'BumpNotFound',\n      `BumpNotFound`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_BORROW_FAILED]: [\n      'AccountBorrowFailed',\n      `AccountBorrowFailed`,\n    ],\n    [LighthouseProgramErrorCode.RANGE_OUT_OF_BOUNDS]: [\n      'RangeOutOfBounds',\n      `RangeOutOfBounds`,\n    ],\n    [LighthouseProgramErrorCode.INDEX_OUT_OF_BOUNDS]: [\n      'IndexOutOfBounds',\n      `IndexOutOfBounds`,\n    ],\n    [LighthouseProgramErrorCode.FAILED_TO_DESERIALIZE]: [\n      'FailedToDeserialize',\n      `FailedToDeserialize`,\n    ],\n    [LighthouseProgramErrorCode.FAILED_TO_SERIALIZE]: [\n      'FailedToSerialize',\n      `FailedToSerialize`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_OWNER_MISMATCH]: [\n      'AccountOwnerMismatch',\n      `AccountOwnerMismatch`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_KEY_MISMATCH]: [\n      'AccountKeyMismatch',\n      `AccountKeyMismatch`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_NOT_INITIALIZED]: [\n      'AccountNotInitialized',\n      `AccountNotInitialized`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_OWNER_VALIDATION_FAILED]: [\n      'AccountOwnerValidationFailed',\n      `AccountOwnerValidationFailed`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_FUNDED_VALIDATION_FAILED]: [\n      'AccountFundedValidationFailed',\n      `AccountFundedValidationFailed`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_DISCRIMINATOR_VALIDATION_FAILED]: [\n      'AccountDiscriminatorValidationFailed',\n      `AccountDiscriminatorValidationFailed`,\n    ],\n    [LighthouseProgramErrorCode.ACCOUNT_VALIDATION_FAILED]: [\n      'AccountValidationFailed',\n      `AccountValidaitonFailed`,\n    ],\n    [LighthouseProgramErrorCode.CROSS_PROGRAM_INVOKE_VIOLATION]: [\n      'CrossProgramInvokeViolation',\n      `CrossProgramInvokeViolation`,\n    ],\n  };\n}\n\nexport function getLighthouseProgramErrorFromCode(\n  code: LighthouseProgramErrorCode,\n  cause?: Error\n): LighthouseProgramError {\n  if (__DEV__) {\n    return new LighthouseProgramError(\n      code,\n      ...(\n        lighthouseProgramErrorCodeMap as Record<\n          LighthouseProgramErrorCode,\n          [string, string]\n        >\n      )[code],\n      cause\n    );\n  }\n\n  return new LighthouseProgramError(\n    code,\n    'Unknown',\n    'Error message not available in production bundles. Compile with __DEV__ set to true to see more information.',\n    cause\n  );\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  DataValueAssertion,\n  DataValueAssertionArgs,\n  LogLevel,\n  LogLevelArgs,\n  getDataValueAssertionDecoder,\n  getDataValueAssertionEncoder,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n} from '../types';\n\nexport type AssertAccountDataInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountDataInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountDataInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  offset: number;\n  assertion: DataValueAssertion;\n};\n\nexport type AssertAccountDataInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  offset: number;\n  assertion: DataValueAssertionArgs;\n};\n\nexport function getAssertAccountDataInstructionDataEncoder(): Encoder<AssertAccountDataInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['offset', getU16Encoder()],\n      ['assertion', getDataValueAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 2,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertAccountDataInstructionDataDecoder(): Decoder<AssertAccountDataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['offset', getU16Decoder()],\n    ['assertion', getDataValueAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertAccountDataInstructionDataCodec(): Codec<\n  AssertAccountDataInstructionDataArgs,\n  AssertAccountDataInstructionData\n> {\n  return combineCodec(\n    getAssertAccountDataInstructionDataEncoder(),\n    getAssertAccountDataInstructionDataDecoder()\n  );\n}\n\nexport type AssertAccountDataInput<TAccountTargetAccount extends string> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertAccountDataInstructionDataArgs['logLevel'];\n  offset: AssertAccountDataInstructionDataArgs['offset'];\n  assertion: AssertAccountDataInstructionDataArgs['assertion'];\n};\n\nexport type AssertAccountDataInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertAccountDataInstructionDataArgs['logLevel'];\n  offset: AssertAccountDataInstructionDataArgs['offset'];\n  assertion: AssertAccountDataInstructionDataArgs['assertion'];\n};\n\nexport function getAssertAccountDataInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountDataInputWithSigners<TAccountTargetAccount>\n): AssertAccountDataInstructionWithSigners<TProgram, TAccountTargetAccount>;\nexport function getAssertAccountDataInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountDataInput<TAccountTargetAccount>\n): AssertAccountDataInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertAccountDataInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertAccountDataInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertAccountDataInstructionRaw<TProgram, TAccountTargetAccount>\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertAccountDataInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertAccountDataInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertAccountDataInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertAccountDataInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertAccountDataInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertAccountDataInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertAccountDataInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertAccountDataInstructionData;\n};\n\nexport function parseAssertAccountDataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertAccountDataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertAccountDataInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  isProgramDerivedAddress,\n  ProgramDerivedAddress,\n} from '@solana/addresses';\nimport {\n  AccountRole,\n  IAccountMeta,\n  upgradeRoleToSigner,\n} from '@solana/instructions';\nimport {\n  IAccountSignerMeta,\n  isTransactionSigner as web3JsIsTransactionSigner,\n  TransactionSigner,\n} from '@solana/signers';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null = Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Add an account meta with a default role if only an address is provided.\n * @internal\n */\nexport function accountMetaWithDefault<\n  TAccount extends string | IAccountMeta<string>,\n  TRole extends AccountRole\n>(account: TAccount | undefined, role: TRole) {\n  if (account === undefined) return undefined;\n  return (\n    typeof account === 'string' ? { address: account, role } : account\n  ) as TAccount extends string\n    ? { address: Address<TAccount>; role: TRole }\n    : TAccount;\n}\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetasWithSigners<TKey extends string = string>(\n  accounts: Record<TKey, ResolvedAccount>,\n  optionalAccountStrategy: 'omitted' | 'programId',\n  programAddress: Address\n): Record<TKey, IAccountMeta | IAccountSignerMeta> {\n  const accountMetas: Record<string, IAccountMeta | IAccountSignerMeta> = {};\n\n  Object.keys(accounts).forEach((key) => {\n    const account = accounts[key as TKey] as ResolvedAccount;\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      accountMetas[key] = {\n        address: programAddress,\n        role: AccountRole.READONLY,\n      };\n      return;\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    accountMetas[key] = Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  });\n\n  return accountMetas;\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    web3JsIsTransactionSigner(value)\n  );\n}\n\nexport function memcmp(data: Uint8Array, bytes: Uint8Array, offset: number) {\n  const slice = data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n} from '@solana/codecs';\nimport {\n  AccountInfoDeltaAssertion,\n  AccountInfoDeltaAssertionArgs,\n  DataValueDeltaAssertion,\n  DataValueDeltaAssertionArgs,\n  getAccountInfoDeltaAssertionDecoder,\n  getAccountInfoDeltaAssertionEncoder,\n  getDataValueDeltaAssertionDecoder,\n  getDataValueDeltaAssertionEncoder,\n} from '.';\n\nexport type AccountDeltaAssertion =\n  | {\n      __kind: 'AccountInfo';\n      aOffset: number;\n      assertion: AccountInfoDeltaAssertion;\n    }\n  | {\n      __kind: 'Data';\n      aOffset: number;\n      bOffset: number;\n      assertion: DataValueDeltaAssertion;\n    };\n\nexport type AccountDeltaAssertionArgs =\n  | {\n      __kind: 'AccountInfo';\n      aOffset: number;\n      assertion: AccountInfoDeltaAssertionArgs;\n    }\n  | {\n      __kind: 'Data';\n      aOffset: number;\n      bOffset: number;\n      assertion: DataValueDeltaAssertionArgs;\n    };\n\nexport function getAccountDeltaAssertionEncoder(): Encoder<AccountDeltaAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'AccountInfo',\n      getStructEncoder([\n        ['aOffset', getU16Encoder()],\n        ['assertion', getAccountInfoDeltaAssertionEncoder()],\n      ]),\n    ],\n    [\n      'Data',\n      getStructEncoder([\n        ['aOffset', getU16Encoder()],\n        ['bOffset', getU16Encoder()],\n        ['assertion', getDataValueDeltaAssertionEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAccountDeltaAssertionDecoder(): Decoder<AccountDeltaAssertion> {\n  return getDataEnumDecoder([\n    [\n      'AccountInfo',\n      getStructDecoder([\n        ['aOffset', getU16Decoder()],\n        ['assertion', getAccountInfoDeltaAssertionDecoder()],\n      ]),\n    ],\n    [\n      'Data',\n      getStructDecoder([\n        ['aOffset', getU16Decoder()],\n        ['bOffset', getU16Decoder()],\n        ['assertion', getDataValueDeltaAssertionDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAccountDeltaAssertionCodec(): Codec<\n  AccountDeltaAssertionArgs,\n  AccountDeltaAssertion\n> {\n  return combineCodec(\n    getAccountDeltaAssertionEncoder(),\n    getAccountDeltaAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function accountDeltaAssertion(\n  kind: 'AccountInfo',\n  data: GetDataEnumKindContent<AccountDeltaAssertionArgs, 'AccountInfo'>\n): GetDataEnumKind<AccountDeltaAssertionArgs, 'AccountInfo'>;\nexport function accountDeltaAssertion(\n  kind: 'Data',\n  data: GetDataEnumKindContent<AccountDeltaAssertionArgs, 'Data'>\n): GetDataEnumKind<AccountDeltaAssertionArgs, 'Data'>;\nexport function accountDeltaAssertion<\n  K extends AccountDeltaAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<AccountDeltaAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isAccountDeltaAssertion<\n  K extends AccountDeltaAssertion['__kind']\n>(\n  kind: K,\n  value: AccountDeltaAssertion\n): value is AccountDeltaAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  Option,\n  OptionOrNullable,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  KnownProgram,\n  KnownProgramArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n  getKnownProgramDecoder,\n  getKnownProgramEncoder,\n} from '.';\n\nexport type AccountInfoAssertion =\n  | { __kind: 'Lamports'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'DataLength'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'Owner'; value: Address; operator: EquatableOperator }\n  | { __kind: 'KnownOwner'; value: KnownProgram; operator: EquatableOperator }\n  | { __kind: 'RentEpoch'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'IsSigner'; value: boolean; operator: EquatableOperator }\n  | { __kind: 'IsWritable'; value: boolean; operator: EquatableOperator }\n  | { __kind: 'Executable'; value: boolean; operator: EquatableOperator }\n  | {\n      __kind: 'VerifyDatahash';\n      expectedHash: Uint8Array;\n      start: Option<number>;\n      length: Option<number>;\n    };\n\nexport type AccountInfoAssertionArgs =\n  | {\n      __kind: 'Lamports';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'DataLength';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | { __kind: 'Owner'; value: Address; operator: EquatableOperatorArgs }\n  | {\n      __kind: 'KnownOwner';\n      value: KnownProgramArgs;\n      operator: EquatableOperatorArgs;\n    }\n  | {\n      __kind: 'RentEpoch';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | { __kind: 'IsSigner'; value: boolean; operator: EquatableOperatorArgs }\n  | { __kind: 'IsWritable'; value: boolean; operator: EquatableOperatorArgs }\n  | { __kind: 'Executable'; value: boolean; operator: EquatableOperatorArgs }\n  | {\n      __kind: 'VerifyDatahash';\n      expectedHash: Uint8Array;\n      start: OptionOrNullable<number>;\n      length: OptionOrNullable<number>;\n    };\n\nexport function getAccountInfoAssertionEncoder(): Encoder<AccountInfoAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'Lamports',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'DataLength',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Owner',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'KnownOwner',\n      getStructEncoder([\n        ['value', getKnownProgramEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'RentEpoch',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'IsSigner',\n      getStructEncoder([\n        ['value', getBooleanEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'IsWritable',\n      getStructEncoder([\n        ['value', getBooleanEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Executable',\n      getStructEncoder([\n        ['value', getBooleanEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'VerifyDatahash',\n      getStructEncoder([\n        ['expectedHash', getBytesEncoder({ size: 32 })],\n        ['start', getOptionEncoder(getU16Encoder())],\n        ['length', getOptionEncoder(getU16Encoder())],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAccountInfoAssertionDecoder(): Decoder<AccountInfoAssertion> {\n  return getDataEnumDecoder([\n    [\n      'Lamports',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'DataLength',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Owner',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'KnownOwner',\n      getStructDecoder([\n        ['value', getKnownProgramDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'RentEpoch',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'IsSigner',\n      getStructDecoder([\n        ['value', getBooleanDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'IsWritable',\n      getStructDecoder([\n        ['value', getBooleanDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Executable',\n      getStructDecoder([\n        ['value', getBooleanDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'VerifyDatahash',\n      getStructDecoder([\n        ['expectedHash', getBytesDecoder({ size: 32 })],\n        ['start', getOptionDecoder(getU16Decoder())],\n        ['length', getOptionDecoder(getU16Decoder())],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAccountInfoAssertionCodec(): Codec<\n  AccountInfoAssertionArgs,\n  AccountInfoAssertion\n> {\n  return combineCodec(\n    getAccountInfoAssertionEncoder(),\n    getAccountInfoAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function accountInfoAssertion(\n  kind: 'Lamports',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'Lamports'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'Lamports'>;\nexport function accountInfoAssertion(\n  kind: 'DataLength',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'DataLength'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'DataLength'>;\nexport function accountInfoAssertion(\n  kind: 'Owner',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'Owner'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'Owner'>;\nexport function accountInfoAssertion(\n  kind: 'KnownOwner',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'KnownOwner'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'KnownOwner'>;\nexport function accountInfoAssertion(\n  kind: 'RentEpoch',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'RentEpoch'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'RentEpoch'>;\nexport function accountInfoAssertion(\n  kind: 'IsSigner',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'IsSigner'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'IsSigner'>;\nexport function accountInfoAssertion(\n  kind: 'IsWritable',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'IsWritable'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'IsWritable'>;\nexport function accountInfoAssertion(\n  kind: 'Executable',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'Executable'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'Executable'>;\nexport function accountInfoAssertion(\n  kind: 'VerifyDatahash',\n  data: GetDataEnumKindContent<AccountInfoAssertionArgs, 'VerifyDatahash'>\n): GetDataEnumKind<AccountInfoAssertionArgs, 'VerifyDatahash'>;\nexport function accountInfoAssertion<\n  K extends AccountInfoAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<AccountInfoAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isAccountInfoAssertion<\n  K extends AccountInfoAssertion['__kind']\n>(\n  kind: K,\n  value: AccountInfoAssertion\n): value is AccountInfoAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getI128Decoder,\n  getI128Encoder,\n  getStructDecoder,\n  getStructEncoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type AccountInfoDeltaAssertion =\n  | { __kind: 'Lamports'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'DataLength'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'Owner'; operator: EquatableOperator }\n  | { __kind: 'RentEpoch'; value: bigint; operator: IntegerOperator };\n\nexport type AccountInfoDeltaAssertionArgs =\n  | {\n      __kind: 'Lamports';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'DataLength';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | { __kind: 'Owner'; operator: EquatableOperatorArgs }\n  | {\n      __kind: 'RentEpoch';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    };\n\nexport function getAccountInfoDeltaAssertionEncoder(): Encoder<AccountInfoDeltaAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'Lamports',\n      getStructEncoder([\n        ['value', getI128Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'DataLength',\n      getStructEncoder([\n        ['value', getI128Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    ['Owner', getStructEncoder([['operator', getEquatableOperatorEncoder()]])],\n    [\n      'RentEpoch',\n      getStructEncoder([\n        ['value', getI128Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAccountInfoDeltaAssertionDecoder(): Decoder<AccountInfoDeltaAssertion> {\n  return getDataEnumDecoder([\n    [\n      'Lamports',\n      getStructDecoder([\n        ['value', getI128Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'DataLength',\n      getStructDecoder([\n        ['value', getI128Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    ['Owner', getStructDecoder([['operator', getEquatableOperatorDecoder()]])],\n    [\n      'RentEpoch',\n      getStructDecoder([\n        ['value', getI128Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAccountInfoDeltaAssertionCodec(): Codec<\n  AccountInfoDeltaAssertionArgs,\n  AccountInfoDeltaAssertion\n> {\n  return combineCodec(\n    getAccountInfoDeltaAssertionEncoder(),\n    getAccountInfoDeltaAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function accountInfoDeltaAssertion(\n  kind: 'Lamports',\n  data: GetDataEnumKindContent<AccountInfoDeltaAssertionArgs, 'Lamports'>\n): GetDataEnumKind<AccountInfoDeltaAssertionArgs, 'Lamports'>;\nexport function accountInfoDeltaAssertion(\n  kind: 'DataLength',\n  data: GetDataEnumKindContent<AccountInfoDeltaAssertionArgs, 'DataLength'>\n): GetDataEnumKind<AccountInfoDeltaAssertionArgs, 'DataLength'>;\nexport function accountInfoDeltaAssertion(\n  kind: 'Owner',\n  data: GetDataEnumKindContent<AccountInfoDeltaAssertionArgs, 'Owner'>\n): GetDataEnumKind<AccountInfoDeltaAssertionArgs, 'Owner'>;\nexport function accountInfoDeltaAssertion(\n  kind: 'RentEpoch',\n  data: GetDataEnumKindContent<AccountInfoDeltaAssertionArgs, 'RentEpoch'>\n): GetDataEnumKind<AccountInfoDeltaAssertionArgs, 'RentEpoch'>;\nexport function accountInfoDeltaAssertion<\n  K extends AccountInfoDeltaAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<AccountInfoDeltaAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isAccountInfoDeltaAssertion<\n  K extends AccountInfoDeltaAssertion['__kind']\n>(\n  kind: K,\n  value: AccountInfoDeltaAssertion\n): value is AccountInfoDeltaAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum AccountInfoField {\n  Key,\n  Lamports,\n  DataLength,\n  Owner,\n  RentEpoch,\n  Executable,\n}\n\nexport type AccountInfoFieldArgs = AccountInfoField;\n\nexport function getAccountInfoFieldEncoder(): Encoder<AccountInfoFieldArgs> {\n  return getScalarEnumEncoder(AccountInfoField);\n}\n\nexport function getAccountInfoFieldDecoder(): Decoder<AccountInfoField> {\n  return getScalarEnumDecoder(AccountInfoField);\n}\n\nexport function getAccountInfoFieldCodec(): Codec<\n  AccountInfoFieldArgs,\n  AccountInfoField\n> {\n  return combineCodec(\n    getAccountInfoFieldEncoder(),\n    getAccountInfoFieldDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  Option,\n  OptionOrNullable,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getI128Decoder,\n  getI128Encoder,\n  getI16Decoder,\n  getI16Encoder,\n  getI32Decoder,\n  getI32Encoder,\n  getI64Decoder,\n  getI64Encoder,\n  getI8Decoder,\n  getI8Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n} from '@solana/codecs';\n\nexport type AssertionResult =\n  | { __kind: 'U8'; fields: [Option<number>, Option<number>, number, boolean] }\n  | { __kind: 'U16'; fields: [Option<number>, Option<number>, number, boolean] }\n  | { __kind: 'U32'; fields: [Option<number>, Option<number>, number, boolean] }\n  | { __kind: 'U64'; fields: [Option<bigint>, Option<bigint>, number, boolean] }\n  | {\n      __kind: 'U128';\n      fields: [Option<bigint>, Option<bigint>, number, boolean];\n    }\n  | { __kind: 'I8'; fields: [Option<number>, Option<number>, number, boolean] }\n  | { __kind: 'I16'; fields: [Option<number>, Option<number>, number, boolean] }\n  | { __kind: 'I32'; fields: [Option<number>, Option<number>, number, boolean] }\n  | { __kind: 'I64'; fields: [Option<bigint>, Option<bigint>, number, boolean] }\n  | {\n      __kind: 'I128';\n      fields: [Option<bigint>, Option<bigint>, number, boolean];\n    }\n  | {\n      __kind: 'Pubkey';\n      fields: [Option<Address>, Option<Address>, number, boolean];\n    }\n  | { __kind: 'Bytes'; fields: [Uint8Array, Uint8Array, number, boolean] }\n  | {\n      __kind: 'Bool';\n      fields: [Option<boolean>, Option<boolean>, number, boolean];\n    };\n\nexport type AssertionResultArgs =\n  | {\n      __kind: 'U8';\n      fields: [\n        OptionOrNullable<number>,\n        OptionOrNullable<number>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'U16';\n      fields: [\n        OptionOrNullable<number>,\n        OptionOrNullable<number>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'U32';\n      fields: [\n        OptionOrNullable<number>,\n        OptionOrNullable<number>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'U64';\n      fields: [\n        OptionOrNullable<number | bigint>,\n        OptionOrNullable<number | bigint>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'U128';\n      fields: [\n        OptionOrNullable<number | bigint>,\n        OptionOrNullable<number | bigint>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'I8';\n      fields: [\n        OptionOrNullable<number>,\n        OptionOrNullable<number>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'I16';\n      fields: [\n        OptionOrNullable<number>,\n        OptionOrNullable<number>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'I32';\n      fields: [\n        OptionOrNullable<number>,\n        OptionOrNullable<number>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'I64';\n      fields: [\n        OptionOrNullable<number | bigint>,\n        OptionOrNullable<number | bigint>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'I128';\n      fields: [\n        OptionOrNullable<number | bigint>,\n        OptionOrNullable<number | bigint>,\n        number,\n        boolean\n      ];\n    }\n  | {\n      __kind: 'Pubkey';\n      fields: [\n        OptionOrNullable<Address>,\n        OptionOrNullable<Address>,\n        number,\n        boolean\n      ];\n    }\n  | { __kind: 'Bytes'; fields: [Uint8Array, Uint8Array, number, boolean] }\n  | {\n      __kind: 'Bool';\n      fields: [\n        OptionOrNullable<boolean>,\n        OptionOrNullable<boolean>,\n        number,\n        boolean\n      ];\n    };\n\nexport function getAssertionResultEncoder(): Encoder<AssertionResultArgs> {\n  return getDataEnumEncoder([\n    [\n      'U8',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getU8Encoder()),\n            getOptionEncoder(getU8Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U16',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getU16Encoder()),\n            getOptionEncoder(getU16Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U32',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getU32Encoder()),\n            getOptionEncoder(getU32Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U64',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getU64Encoder()),\n            getOptionEncoder(getU64Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U128',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getU128Encoder()),\n            getOptionEncoder(getU128Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I8',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getI8Encoder()),\n            getOptionEncoder(getI8Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I16',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getI16Encoder()),\n            getOptionEncoder(getI16Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I32',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getI32Encoder()),\n            getOptionEncoder(getI32Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I64',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getI64Encoder()),\n            getOptionEncoder(getI64Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I128',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getI128Encoder()),\n            getOptionEncoder(getI128Encoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'Pubkey',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getAddressEncoder()),\n            getOptionEncoder(getAddressEncoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'Bytes',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getBytesEncoder({ size: getU32Encoder() }),\n            getBytesEncoder({ size: getU32Encoder() }),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'Bool',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            getOptionEncoder(getBooleanEncoder()),\n            getOptionEncoder(getBooleanEncoder()),\n            getU8Encoder(),\n            getBooleanEncoder(),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAssertionResultDecoder(): Decoder<AssertionResult> {\n  return getDataEnumDecoder([\n    [\n      'U8',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getU8Decoder()),\n            getOptionDecoder(getU8Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U16',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getU16Decoder()),\n            getOptionDecoder(getU16Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U32',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getU32Decoder()),\n            getOptionDecoder(getU32Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U64',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getU64Decoder()),\n            getOptionDecoder(getU64Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'U128',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getU128Decoder()),\n            getOptionDecoder(getU128Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I8',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getI8Decoder()),\n            getOptionDecoder(getI8Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I16',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getI16Decoder()),\n            getOptionDecoder(getI16Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I32',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getI32Decoder()),\n            getOptionDecoder(getI32Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I64',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getI64Decoder()),\n            getOptionDecoder(getI64Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'I128',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getI128Decoder()),\n            getOptionDecoder(getI128Decoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'Pubkey',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getAddressDecoder()),\n            getOptionDecoder(getAddressDecoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'Bytes',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getBytesDecoder({ size: getU32Decoder() }),\n            getBytesDecoder({ size: getU32Decoder() }),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n    [\n      'Bool',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            getOptionDecoder(getBooleanDecoder()),\n            getOptionDecoder(getBooleanDecoder()),\n            getU8Decoder(),\n            getBooleanDecoder(),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getAssertionResultCodec(): Codec<\n  AssertionResultArgs,\n  AssertionResult\n> {\n  return combineCodec(getAssertionResultEncoder(), getAssertionResultDecoder());\n}\n\n// Data Enum Helpers.\nexport function assertionResult(\n  kind: 'U8',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'U8'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'U8'>;\nexport function assertionResult(\n  kind: 'U16',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'U16'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'U16'>;\nexport function assertionResult(\n  kind: 'U32',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'U32'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'U32'>;\nexport function assertionResult(\n  kind: 'U64',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'U64'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'U64'>;\nexport function assertionResult(\n  kind: 'U128',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'U128'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'U128'>;\nexport function assertionResult(\n  kind: 'I8',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'I8'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'I8'>;\nexport function assertionResult(\n  kind: 'I16',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'I16'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'I16'>;\nexport function assertionResult(\n  kind: 'I32',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'I32'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'I32'>;\nexport function assertionResult(\n  kind: 'I64',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'I64'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'I64'>;\nexport function assertionResult(\n  kind: 'I128',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'I128'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'I128'>;\nexport function assertionResult(\n  kind: 'Pubkey',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'Pubkey'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'Pubkey'>;\nexport function assertionResult(\n  kind: 'Bytes',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'Bytes'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'Bytes'>;\nexport function assertionResult(\n  kind: 'Bool',\n  data: GetDataEnumKindContent<AssertionResultArgs, 'Bool'>['fields']\n): GetDataEnumKind<AssertionResultArgs, 'Bool'>;\nexport function assertionResult<K extends AssertionResultArgs['__kind']>(\n  kind: K,\n  data?: any\n): Extract<AssertionResultArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isAssertionResult<K extends AssertionResult['__kind']>(\n  kind: K,\n  value: AssertionResult\n): value is AssertionResult & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum ByteSliceOperator {\n  Equal,\n  NotEqual,\n}\n\nexport type ByteSliceOperatorArgs = ByteSliceOperator;\n\nexport function getByteSliceOperatorEncoder(): Encoder<ByteSliceOperatorArgs> {\n  return getScalarEnumEncoder(ByteSliceOperator);\n}\n\nexport function getByteSliceOperatorDecoder(): Decoder<ByteSliceOperator> {\n  return getScalarEnumDecoder(ByteSliceOperator);\n}\n\nexport function getByteSliceOperatorCodec(): Codec<\n  ByteSliceOperatorArgs,\n  ByteSliceOperator\n> {\n  return combineCodec(\n    getByteSliceOperatorEncoder(),\n    getByteSliceOperatorDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum ClockField {\n  Slot,\n  EpochStartTimestamp,\n  Epoch,\n  LeaderScheduleEpoch,\n  UnixTimestamp,\n}\n\nexport type ClockFieldArgs = ClockField;\n\nexport function getClockFieldEncoder(): Encoder<ClockFieldArgs> {\n  return getScalarEnumEncoder(ClockField);\n}\n\nexport function getClockFieldDecoder(): Decoder<ClockField> {\n  return getScalarEnumDecoder(ClockField);\n}\n\nexport function getClockFieldCodec(): Codec<ClockFieldArgs, ClockField> {\n  return combineCodec(getClockFieldEncoder(), getClockFieldDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getI128Decoder,\n  getI128Encoder,\n  getI16Decoder,\n  getI16Encoder,\n  getI32Decoder,\n  getI32Encoder,\n  getI64Decoder,\n  getI64Encoder,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n} from '@solana/codecs';\n\nexport type DataValue =\n  | { __kind: 'Bool'; fields: [boolean] }\n  | { __kind: 'U8'; fields: [number] }\n  | { __kind: 'I8'; fields: [number] }\n  | { __kind: 'U16'; fields: [number] }\n  | { __kind: 'I16'; fields: [number] }\n  | { __kind: 'U32'; fields: [number] }\n  | { __kind: 'I32'; fields: [number] }\n  | { __kind: 'U64'; fields: [bigint] }\n  | { __kind: 'I64'; fields: [bigint] }\n  | { __kind: 'U128'; fields: [bigint] }\n  | { __kind: 'I128'; fields: [bigint] }\n  | { __kind: 'Bytes'; fields: [Uint8Array] }\n  | { __kind: 'Pubkey'; fields: [Address] };\n\nexport type DataValueArgs =\n  | { __kind: 'Bool'; fields: [boolean] }\n  | { __kind: 'U8'; fields: [number] }\n  | { __kind: 'I8'; fields: [number] }\n  | { __kind: 'U16'; fields: [number] }\n  | { __kind: 'I16'; fields: [number] }\n  | { __kind: 'U32'; fields: [number] }\n  | { __kind: 'I32'; fields: [number] }\n  | { __kind: 'U64'; fields: [number | bigint] }\n  | { __kind: 'I64'; fields: [number | bigint] }\n  | { __kind: 'U128'; fields: [number | bigint] }\n  | { __kind: 'I128'; fields: [number | bigint] }\n  | { __kind: 'Bytes'; fields: [Uint8Array] }\n  | { __kind: 'Pubkey'; fields: [Address] };\n\nexport function getDataValueEncoder(): Encoder<DataValueArgs> {\n  return getDataEnumEncoder([\n    [\n      'Bool',\n      getStructEncoder([['fields', getTupleEncoder([getBooleanEncoder()])]]),\n    ],\n    ['U8', getStructEncoder([['fields', getTupleEncoder([getU8Encoder()])]])],\n    ['I8', getStructEncoder([['fields', getTupleEncoder([getI8Encoder()])]])],\n    ['U16', getStructEncoder([['fields', getTupleEncoder([getU16Encoder()])]])],\n    ['I16', getStructEncoder([['fields', getTupleEncoder([getI16Encoder()])]])],\n    ['U32', getStructEncoder([['fields', getTupleEncoder([getU32Encoder()])]])],\n    ['I32', getStructEncoder([['fields', getTupleEncoder([getI32Encoder()])]])],\n    ['U64', getStructEncoder([['fields', getTupleEncoder([getU64Encoder()])]])],\n    ['I64', getStructEncoder([['fields', getTupleEncoder([getI64Encoder()])]])],\n    [\n      'U128',\n      getStructEncoder([['fields', getTupleEncoder([getU128Encoder()])]]),\n    ],\n    [\n      'I128',\n      getStructEncoder([['fields', getTupleEncoder([getI128Encoder()])]]),\n    ],\n    [\n      'Bytes',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([getBytesEncoder({ size: getU32Encoder() })]),\n        ],\n      ]),\n    ],\n    [\n      'Pubkey',\n      getStructEncoder([['fields', getTupleEncoder([getAddressEncoder()])]]),\n    ],\n  ]);\n}\n\nexport function getDataValueDecoder(): Decoder<DataValue> {\n  return getDataEnumDecoder([\n    [\n      'Bool',\n      getStructDecoder([['fields', getTupleDecoder([getBooleanDecoder()])]]),\n    ],\n    ['U8', getStructDecoder([['fields', getTupleDecoder([getU8Decoder()])]])],\n    ['I8', getStructDecoder([['fields', getTupleDecoder([getI8Decoder()])]])],\n    ['U16', getStructDecoder([['fields', getTupleDecoder([getU16Decoder()])]])],\n    ['I16', getStructDecoder([['fields', getTupleDecoder([getI16Decoder()])]])],\n    ['U32', getStructDecoder([['fields', getTupleDecoder([getU32Decoder()])]])],\n    ['I32', getStructDecoder([['fields', getTupleDecoder([getI32Decoder()])]])],\n    ['U64', getStructDecoder([['fields', getTupleDecoder([getU64Decoder()])]])],\n    ['I64', getStructDecoder([['fields', getTupleDecoder([getI64Decoder()])]])],\n    [\n      'U128',\n      getStructDecoder([['fields', getTupleDecoder([getU128Decoder()])]]),\n    ],\n    [\n      'I128',\n      getStructDecoder([['fields', getTupleDecoder([getI128Decoder()])]]),\n    ],\n    [\n      'Bytes',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([getBytesDecoder({ size: getU32Decoder() })]),\n        ],\n      ]),\n    ],\n    [\n      'Pubkey',\n      getStructDecoder([['fields', getTupleDecoder([getAddressDecoder()])]]),\n    ],\n  ]);\n}\n\nexport function getDataValueCodec(): Codec<DataValueArgs, DataValue> {\n  return combineCodec(getDataValueEncoder(), getDataValueDecoder());\n}\n\n// Data Enum Helpers.\nexport function dataValue(\n  kind: 'Bool',\n  data: GetDataEnumKindContent<DataValueArgs, 'Bool'>['fields']\n): GetDataEnumKind<DataValueArgs, 'Bool'>;\nexport function dataValue(\n  kind: 'U8',\n  data: GetDataEnumKindContent<DataValueArgs, 'U8'>['fields']\n): GetDataEnumKind<DataValueArgs, 'U8'>;\nexport function dataValue(\n  kind: 'I8',\n  data: GetDataEnumKindContent<DataValueArgs, 'I8'>['fields']\n): GetDataEnumKind<DataValueArgs, 'I8'>;\nexport function dataValue(\n  kind: 'U16',\n  data: GetDataEnumKindContent<DataValueArgs, 'U16'>['fields']\n): GetDataEnumKind<DataValueArgs, 'U16'>;\nexport function dataValue(\n  kind: 'I16',\n  data: GetDataEnumKindContent<DataValueArgs, 'I16'>['fields']\n): GetDataEnumKind<DataValueArgs, 'I16'>;\nexport function dataValue(\n  kind: 'U32',\n  data: GetDataEnumKindContent<DataValueArgs, 'U32'>['fields']\n): GetDataEnumKind<DataValueArgs, 'U32'>;\nexport function dataValue(\n  kind: 'I32',\n  data: GetDataEnumKindContent<DataValueArgs, 'I32'>['fields']\n): GetDataEnumKind<DataValueArgs, 'I32'>;\nexport function dataValue(\n  kind: 'U64',\n  data: GetDataEnumKindContent<DataValueArgs, 'U64'>['fields']\n): GetDataEnumKind<DataValueArgs, 'U64'>;\nexport function dataValue(\n  kind: 'I64',\n  data: GetDataEnumKindContent<DataValueArgs, 'I64'>['fields']\n): GetDataEnumKind<DataValueArgs, 'I64'>;\nexport function dataValue(\n  kind: 'U128',\n  data: GetDataEnumKindContent<DataValueArgs, 'U128'>['fields']\n): GetDataEnumKind<DataValueArgs, 'U128'>;\nexport function dataValue(\n  kind: 'I128',\n  data: GetDataEnumKindContent<DataValueArgs, 'I128'>['fields']\n): GetDataEnumKind<DataValueArgs, 'I128'>;\nexport function dataValue(\n  kind: 'Bytes',\n  data: GetDataEnumKindContent<DataValueArgs, 'Bytes'>['fields']\n): GetDataEnumKind<DataValueArgs, 'Bytes'>;\nexport function dataValue(\n  kind: 'Pubkey',\n  data: GetDataEnumKindContent<DataValueArgs, 'Pubkey'>['fields']\n): GetDataEnumKind<DataValueArgs, 'Pubkey'>;\nexport function dataValue<K extends DataValueArgs['__kind']>(\n  kind: K,\n  data?: any\n): Extract<DataValueArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isDataValue<K extends DataValue['__kind']>(\n  kind: K,\n  value: DataValue\n): value is DataValue & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getI128Decoder,\n  getI128Encoder,\n  getI16Decoder,\n  getI16Encoder,\n  getI32Decoder,\n  getI32Encoder,\n  getI64Decoder,\n  getI64Encoder,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n} from '@solana/codecs';\nimport {\n  ByteSliceOperator,\n  ByteSliceOperatorArgs,\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getByteSliceOperatorDecoder,\n  getByteSliceOperatorEncoder,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type DataValueAssertion =\n  | { __kind: 'Bool'; value: boolean; operator: EquatableOperator }\n  | { __kind: 'U8'; value: number; operator: IntegerOperator }\n  | { __kind: 'I8'; value: number; operator: IntegerOperator }\n  | { __kind: 'U16'; value: number; operator: IntegerOperator }\n  | { __kind: 'I16'; value: number; operator: IntegerOperator }\n  | { __kind: 'U32'; value: number; operator: IntegerOperator }\n  | { __kind: 'I32'; value: number; operator: IntegerOperator }\n  | { __kind: 'U64'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'I64'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'U128'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'I128'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'Bytes'; value: Uint8Array; operator: ByteSliceOperator }\n  | { __kind: 'Pubkey'; value: Address; operator: EquatableOperator };\n\nexport type DataValueAssertionArgs =\n  | { __kind: 'Bool'; value: boolean; operator: EquatableOperatorArgs }\n  | { __kind: 'U8'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'I8'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'U16'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'I16'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'U32'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'I32'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'U64'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'I64'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'U128'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'I128'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'Bytes'; value: Uint8Array; operator: ByteSliceOperatorArgs }\n  | { __kind: 'Pubkey'; value: Address; operator: EquatableOperatorArgs };\n\nexport function getDataValueAssertionEncoder(): Encoder<DataValueAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'Bool',\n      getStructEncoder([\n        ['value', getBooleanEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U8',\n      getStructEncoder([\n        ['value', getU8Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I8',\n      getStructEncoder([\n        ['value', getI8Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U16',\n      getStructEncoder([\n        ['value', getU16Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I16',\n      getStructEncoder([\n        ['value', getI16Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U32',\n      getStructEncoder([\n        ['value', getU32Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I32',\n      getStructEncoder([\n        ['value', getI32Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U64',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I64',\n      getStructEncoder([\n        ['value', getI64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U128',\n      getStructEncoder([\n        ['value', getU128Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I128',\n      getStructEncoder([\n        ['value', getI128Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Bytes',\n      getStructEncoder([\n        ['value', getBytesEncoder({ size: getU32Encoder() })],\n        ['operator', getByteSliceOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Pubkey',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getDataValueAssertionDecoder(): Decoder<DataValueAssertion> {\n  return getDataEnumDecoder([\n    [\n      'Bool',\n      getStructDecoder([\n        ['value', getBooleanDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U8',\n      getStructDecoder([\n        ['value', getU8Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I8',\n      getStructDecoder([\n        ['value', getI8Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U16',\n      getStructDecoder([\n        ['value', getU16Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I16',\n      getStructDecoder([\n        ['value', getI16Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U32',\n      getStructDecoder([\n        ['value', getU32Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I32',\n      getStructDecoder([\n        ['value', getI32Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U64',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I64',\n      getStructDecoder([\n        ['value', getI64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U128',\n      getStructDecoder([\n        ['value', getU128Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I128',\n      getStructDecoder([\n        ['value', getI128Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Bytes',\n      getStructDecoder([\n        ['value', getBytesDecoder({ size: getU32Decoder() })],\n        ['operator', getByteSliceOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Pubkey',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getDataValueAssertionCodec(): Codec<\n  DataValueAssertionArgs,\n  DataValueAssertion\n> {\n  return combineCodec(\n    getDataValueAssertionEncoder(),\n    getDataValueAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function dataValueAssertion(\n  kind: 'Bool',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'Bool'>\n): GetDataEnumKind<DataValueAssertionArgs, 'Bool'>;\nexport function dataValueAssertion(\n  kind: 'U8',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'U8'>\n): GetDataEnumKind<DataValueAssertionArgs, 'U8'>;\nexport function dataValueAssertion(\n  kind: 'I8',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'I8'>\n): GetDataEnumKind<DataValueAssertionArgs, 'I8'>;\nexport function dataValueAssertion(\n  kind: 'U16',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'U16'>\n): GetDataEnumKind<DataValueAssertionArgs, 'U16'>;\nexport function dataValueAssertion(\n  kind: 'I16',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'I16'>\n): GetDataEnumKind<DataValueAssertionArgs, 'I16'>;\nexport function dataValueAssertion(\n  kind: 'U32',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'U32'>\n): GetDataEnumKind<DataValueAssertionArgs, 'U32'>;\nexport function dataValueAssertion(\n  kind: 'I32',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'I32'>\n): GetDataEnumKind<DataValueAssertionArgs, 'I32'>;\nexport function dataValueAssertion(\n  kind: 'U64',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'U64'>\n): GetDataEnumKind<DataValueAssertionArgs, 'U64'>;\nexport function dataValueAssertion(\n  kind: 'I64',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'I64'>\n): GetDataEnumKind<DataValueAssertionArgs, 'I64'>;\nexport function dataValueAssertion(\n  kind: 'U128',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'U128'>\n): GetDataEnumKind<DataValueAssertionArgs, 'U128'>;\nexport function dataValueAssertion(\n  kind: 'I128',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'I128'>\n): GetDataEnumKind<DataValueAssertionArgs, 'I128'>;\nexport function dataValueAssertion(\n  kind: 'Bytes',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'Bytes'>\n): GetDataEnumKind<DataValueAssertionArgs, 'Bytes'>;\nexport function dataValueAssertion(\n  kind: 'Pubkey',\n  data: GetDataEnumKindContent<DataValueAssertionArgs, 'Pubkey'>\n): GetDataEnumKind<DataValueAssertionArgs, 'Pubkey'>;\nexport function dataValueAssertion<K extends DataValueAssertionArgs['__kind']>(\n  kind: K,\n  data?: any\n): Extract<DataValueAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isDataValueAssertion<K extends DataValueAssertion['__kind']>(\n  kind: K,\n  value: DataValueAssertion\n): value is DataValueAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getI128Decoder,\n  getI128Encoder,\n  getI16Decoder,\n  getI16Encoder,\n  getI32Decoder,\n  getI32Encoder,\n  getI64Decoder,\n  getI64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n} from '@solana/codecs';\nimport {\n  ByteSliceOperator,\n  ByteSliceOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getByteSliceOperatorDecoder,\n  getByteSliceOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type DataValueDeltaAssertion =\n  | { __kind: 'U8'; value: number; operator: IntegerOperator }\n  | { __kind: 'I8'; value: number; operator: IntegerOperator }\n  | { __kind: 'U16'; value: number; operator: IntegerOperator }\n  | { __kind: 'I16'; value: number; operator: IntegerOperator }\n  | { __kind: 'U32'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'I32'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'U64'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'I64'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'Bytes'; length: number; operator: ByteSliceOperator };\n\nexport type DataValueDeltaAssertionArgs =\n  | { __kind: 'U8'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'I8'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'U16'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'I16'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'U32'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'I32'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'U64'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'I64'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'Bytes'; length: number; operator: ByteSliceOperatorArgs };\n\nexport function getDataValueDeltaAssertionEncoder(): Encoder<DataValueDeltaAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'U8',\n      getStructEncoder([\n        ['value', getI16Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I8',\n      getStructEncoder([\n        ['value', getI16Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U16',\n      getStructEncoder([\n        ['value', getI32Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I16',\n      getStructEncoder([\n        ['value', getI32Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U32',\n      getStructEncoder([\n        ['value', getI64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I32',\n      getStructEncoder([\n        ['value', getI64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'U64',\n      getStructEncoder([\n        ['value', getI128Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'I64',\n      getStructEncoder([\n        ['value', getI128Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Bytes',\n      getStructEncoder([\n        ['length', getU16Encoder()],\n        ['operator', getByteSliceOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getDataValueDeltaAssertionDecoder(): Decoder<DataValueDeltaAssertion> {\n  return getDataEnumDecoder([\n    [\n      'U8',\n      getStructDecoder([\n        ['value', getI16Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I8',\n      getStructDecoder([\n        ['value', getI16Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U16',\n      getStructDecoder([\n        ['value', getI32Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I16',\n      getStructDecoder([\n        ['value', getI32Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U32',\n      getStructDecoder([\n        ['value', getI64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I32',\n      getStructDecoder([\n        ['value', getI64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'U64',\n      getStructDecoder([\n        ['value', getI128Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'I64',\n      getStructDecoder([\n        ['value', getI128Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Bytes',\n      getStructDecoder([\n        ['length', getU16Decoder()],\n        ['operator', getByteSliceOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getDataValueDeltaAssertionCodec(): Codec<\n  DataValueDeltaAssertionArgs,\n  DataValueDeltaAssertion\n> {\n  return combineCodec(\n    getDataValueDeltaAssertionEncoder(),\n    getDataValueDeltaAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function dataValueDeltaAssertion(\n  kind: 'U8',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'U8'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'U8'>;\nexport function dataValueDeltaAssertion(\n  kind: 'I8',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'I8'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'I8'>;\nexport function dataValueDeltaAssertion(\n  kind: 'U16',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'U16'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'U16'>;\nexport function dataValueDeltaAssertion(\n  kind: 'I16',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'I16'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'I16'>;\nexport function dataValueDeltaAssertion(\n  kind: 'U32',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'U32'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'U32'>;\nexport function dataValueDeltaAssertion(\n  kind: 'I32',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'I32'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'I32'>;\nexport function dataValueDeltaAssertion(\n  kind: 'U64',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'U64'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'U64'>;\nexport function dataValueDeltaAssertion(\n  kind: 'I64',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'I64'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'I64'>;\nexport function dataValueDeltaAssertion(\n  kind: 'Bytes',\n  data: GetDataEnumKindContent<DataValueDeltaAssertionArgs, 'Bytes'>\n): GetDataEnumKind<DataValueDeltaAssertionArgs, 'Bytes'>;\nexport function dataValueDeltaAssertion<\n  K extends DataValueDeltaAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<DataValueDeltaAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isDataValueDeltaAssertion<\n  K extends DataValueDeltaAssertion['__kind']\n>(\n  kind: K,\n  value: DataValueDeltaAssertion\n): value is DataValueDeltaAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum EquatableOperator {\n  Equal,\n  NotEqual,\n}\n\nexport type EquatableOperatorArgs = EquatableOperator;\n\nexport function getEquatableOperatorEncoder(): Encoder<EquatableOperatorArgs> {\n  return getScalarEnumEncoder(EquatableOperator);\n}\n\nexport function getEquatableOperatorDecoder(): Decoder<EquatableOperator> {\n  return getScalarEnumDecoder(EquatableOperator);\n}\n\nexport function getEquatableOperatorCodec(): Codec<\n  EquatableOperatorArgs,\n  EquatableOperator\n> {\n  return combineCodec(\n    getEquatableOperatorEncoder(),\n    getEquatableOperatorDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum IntegerOperator {\n  Equal,\n  NotEqual,\n  GreaterThan,\n  LessThan,\n  GreaterThanOrEqual,\n  LessThanOrEqual,\n  Contains,\n  DoesNotContain,\n}\n\nexport type IntegerOperatorArgs = IntegerOperator;\n\nexport function getIntegerOperatorEncoder(): Encoder<IntegerOperatorArgs> {\n  return getScalarEnumEncoder(IntegerOperator);\n}\n\nexport function getIntegerOperatorDecoder(): Decoder<IntegerOperator> {\n  return getScalarEnumDecoder(IntegerOperator);\n}\n\nexport function getIntegerOperatorCodec(): Codec<\n  IntegerOperatorArgs,\n  IntegerOperator\n> {\n  return combineCodec(getIntegerOperatorEncoder(), getIntegerOperatorDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum KnownProgram {\n  System,\n  Token,\n  Token2022,\n  Rent,\n  Stake,\n  Vote,\n  BpfLoader,\n  UpgradeableLoader,\n  SysvarConfig,\n}\n\nexport type KnownProgramArgs = KnownProgram;\n\nexport function getKnownProgramEncoder(): Encoder<KnownProgramArgs> {\n  return getScalarEnumEncoder(KnownProgram);\n}\n\nexport function getKnownProgramDecoder(): Decoder<KnownProgram> {\n  return getScalarEnumDecoder(KnownProgram);\n}\n\nexport function getKnownProgramCodec(): Codec<KnownProgramArgs, KnownProgram> {\n  return combineCodec(getKnownProgramEncoder(), getKnownProgramDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum LogLevel {\n  Silent,\n  PlaintextMessage,\n  EncodedMessage,\n  EncodedNoop,\n}\n\nexport type LogLevelArgs = LogLevel;\n\nexport function getLogLevelEncoder(): Encoder<LogLevelArgs> {\n  return getScalarEnumEncoder(LogLevel);\n}\n\nexport function getLogLevelDecoder(): Decoder<LogLevel> {\n  return getScalarEnumDecoder(LogLevel);\n}\n\nexport function getLogLevelCodec(): Codec<LogLevelArgs, LogLevel> {\n  return combineCodec(getLogLevelEncoder(), getLogLevelDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n} from '@solana/codecs';\n\nexport type MerkleTreeAssertion = {\n  __kind: 'VerifyLeaf';\n  leafIndex: number;\n  leafHash: Uint8Array;\n};\n\nexport type MerkleTreeAssertionArgs = MerkleTreeAssertion;\n\nexport function getMerkleTreeAssertionEncoder(): Encoder<MerkleTreeAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'VerifyLeaf',\n      getStructEncoder([\n        ['leafIndex', getU32Encoder()],\n        ['leafHash', getBytesEncoder({ size: 32 })],\n      ]),\n    ],\n  ]);\n}\n\nexport function getMerkleTreeAssertionDecoder(): Decoder<MerkleTreeAssertion> {\n  return getDataEnumDecoder([\n    [\n      'VerifyLeaf',\n      getStructDecoder([\n        ['leafIndex', getU32Decoder()],\n        ['leafHash', getBytesDecoder({ size: 32 })],\n      ]),\n    ],\n  ]);\n}\n\nexport function getMerkleTreeAssertionCodec(): Codec<\n  MerkleTreeAssertionArgs,\n  MerkleTreeAssertion\n> {\n  return combineCodec(\n    getMerkleTreeAssertionEncoder(),\n    getMerkleTreeAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function merkleTreeAssertion(\n  kind: 'VerifyLeaf',\n  data: GetDataEnumKindContent<MerkleTreeAssertionArgs, 'VerifyLeaf'>\n): GetDataEnumKind<MerkleTreeAssertionArgs, 'VerifyLeaf'>;\nexport function merkleTreeAssertion<\n  K extends MerkleTreeAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<MerkleTreeAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isMerkleTreeAssertion<K extends MerkleTreeAssertion['__kind']>(\n  kind: K,\n  value: MerkleTreeAssertion\n): value is MerkleTreeAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getI64Decoder,\n  getI64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type MetaAssertion =\n  | { __kind: 'RentExemptReserve'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'AuthorizedStaker'; value: Address; operator: EquatableOperator }\n  | {\n      __kind: 'AuthorizedWithdrawer';\n      value: Address;\n      operator: EquatableOperator;\n    }\n  | { __kind: 'LockupUnixTimestamp'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'LockupEpoch'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'LockupCustodian'; value: Address; operator: EquatableOperator };\n\nexport type MetaAssertionArgs =\n  | {\n      __kind: 'RentExemptReserve';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'AuthorizedStaker';\n      value: Address;\n      operator: EquatableOperatorArgs;\n    }\n  | {\n      __kind: 'AuthorizedWithdrawer';\n      value: Address;\n      operator: EquatableOperatorArgs;\n    }\n  | {\n      __kind: 'LockupUnixTimestamp';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'LockupEpoch';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'LockupCustodian';\n      value: Address;\n      operator: EquatableOperatorArgs;\n    };\n\nexport function getMetaAssertionEncoder(): Encoder<MetaAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'RentExemptReserve',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'AuthorizedStaker',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'AuthorizedWithdrawer',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'LockupUnixTimestamp',\n      getStructEncoder([\n        ['value', getI64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'LockupEpoch',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'LockupCustodian',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getMetaAssertionDecoder(): Decoder<MetaAssertion> {\n  return getDataEnumDecoder([\n    [\n      'RentExemptReserve',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'AuthorizedStaker',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'AuthorizedWithdrawer',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'LockupUnixTimestamp',\n      getStructDecoder([\n        ['value', getI64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'LockupEpoch',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'LockupCustodian',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getMetaAssertionCodec(): Codec<\n  MetaAssertionArgs,\n  MetaAssertion\n> {\n  return combineCodec(getMetaAssertionEncoder(), getMetaAssertionDecoder());\n}\n\n// Data Enum Helpers.\nexport function metaAssertion(\n  kind: 'RentExemptReserve',\n  data: GetDataEnumKindContent<MetaAssertionArgs, 'RentExemptReserve'>\n): GetDataEnumKind<MetaAssertionArgs, 'RentExemptReserve'>;\nexport function metaAssertion(\n  kind: 'AuthorizedStaker',\n  data: GetDataEnumKindContent<MetaAssertionArgs, 'AuthorizedStaker'>\n): GetDataEnumKind<MetaAssertionArgs, 'AuthorizedStaker'>;\nexport function metaAssertion(\n  kind: 'AuthorizedWithdrawer',\n  data: GetDataEnumKindContent<MetaAssertionArgs, 'AuthorizedWithdrawer'>\n): GetDataEnumKind<MetaAssertionArgs, 'AuthorizedWithdrawer'>;\nexport function metaAssertion(\n  kind: 'LockupUnixTimestamp',\n  data: GetDataEnumKindContent<MetaAssertionArgs, 'LockupUnixTimestamp'>\n): GetDataEnumKind<MetaAssertionArgs, 'LockupUnixTimestamp'>;\nexport function metaAssertion(\n  kind: 'LockupEpoch',\n  data: GetDataEnumKindContent<MetaAssertionArgs, 'LockupEpoch'>\n): GetDataEnumKind<MetaAssertionArgs, 'LockupEpoch'>;\nexport function metaAssertion(\n  kind: 'LockupCustodian',\n  data: GetDataEnumKindContent<MetaAssertionArgs, 'LockupCustodian'>\n): GetDataEnumKind<MetaAssertionArgs, 'LockupCustodian'>;\nexport function metaAssertion<K extends MetaAssertionArgs['__kind']>(\n  kind: K,\n  data?: any\n): Extract<MetaAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isMetaAssertion<K extends MetaAssertion['__kind']>(\n  kind: K,\n  value: MetaAssertion\n): value is MetaAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  Option,\n  OptionOrNullable,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type MintAccountAssertion =\n  | {\n      __kind: 'MintAuthority';\n      value: Option<Address>;\n      operator: EquatableOperator;\n    }\n  | { __kind: 'Supply'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'Decimals'; value: number; operator: IntegerOperator }\n  | { __kind: 'IsInitialized'; value: boolean; operator: EquatableOperator }\n  | {\n      __kind: 'FreezeAuthority';\n      value: Option<Address>;\n      operator: EquatableOperator;\n    };\n\nexport type MintAccountAssertionArgs =\n  | {\n      __kind: 'MintAuthority';\n      value: OptionOrNullable<Address>;\n      operator: EquatableOperatorArgs;\n    }\n  | { __kind: 'Supply'; value: number | bigint; operator: IntegerOperatorArgs }\n  | { __kind: 'Decimals'; value: number; operator: IntegerOperatorArgs }\n  | { __kind: 'IsInitialized'; value: boolean; operator: EquatableOperatorArgs }\n  | {\n      __kind: 'FreezeAuthority';\n      value: OptionOrNullable<Address>;\n      operator: EquatableOperatorArgs;\n    };\n\nexport function getMintAccountAssertionEncoder(): Encoder<MintAccountAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'MintAuthority',\n      getStructEncoder([\n        ['value', getOptionEncoder(getAddressEncoder())],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Supply',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Decimals',\n      getStructEncoder([\n        ['value', getU8Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'IsInitialized',\n      getStructEncoder([\n        ['value', getBooleanEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'FreezeAuthority',\n      getStructEncoder([\n        ['value', getOptionEncoder(getAddressEncoder())],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getMintAccountAssertionDecoder(): Decoder<MintAccountAssertion> {\n  return getDataEnumDecoder([\n    [\n      'MintAuthority',\n      getStructDecoder([\n        ['value', getOptionDecoder(getAddressDecoder())],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Supply',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Decimals',\n      getStructDecoder([\n        ['value', getU8Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'IsInitialized',\n      getStructDecoder([\n        ['value', getBooleanDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'FreezeAuthority',\n      getStructDecoder([\n        ['value', getOptionDecoder(getAddressDecoder())],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getMintAccountAssertionCodec(): Codec<\n  MintAccountAssertionArgs,\n  MintAccountAssertion\n> {\n  return combineCodec(\n    getMintAccountAssertionEncoder(),\n    getMintAccountAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function mintAccountAssertion(\n  kind: 'MintAuthority',\n  data: GetDataEnumKindContent<MintAccountAssertionArgs, 'MintAuthority'>\n): GetDataEnumKind<MintAccountAssertionArgs, 'MintAuthority'>;\nexport function mintAccountAssertion(\n  kind: 'Supply',\n  data: GetDataEnumKindContent<MintAccountAssertionArgs, 'Supply'>\n): GetDataEnumKind<MintAccountAssertionArgs, 'Supply'>;\nexport function mintAccountAssertion(\n  kind: 'Decimals',\n  data: GetDataEnumKindContent<MintAccountAssertionArgs, 'Decimals'>\n): GetDataEnumKind<MintAccountAssertionArgs, 'Decimals'>;\nexport function mintAccountAssertion(\n  kind: 'IsInitialized',\n  data: GetDataEnumKindContent<MintAccountAssertionArgs, 'IsInitialized'>\n): GetDataEnumKind<MintAccountAssertionArgs, 'IsInitialized'>;\nexport function mintAccountAssertion(\n  kind: 'FreezeAuthority',\n  data: GetDataEnumKindContent<MintAccountAssertionArgs, 'FreezeAuthority'>\n): GetDataEnumKind<MintAccountAssertionArgs, 'FreezeAuthority'>;\nexport function mintAccountAssertion<\n  K extends MintAccountAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<MintAccountAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isMintAccountAssertion<\n  K extends MintAccountAssertion['__kind']\n>(\n  kind: K,\n  value: MintAccountAssertion\n): value is MintAccountAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU8Decoder,\n  getU8Encoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  MetaAssertion,\n  MetaAssertionArgs,\n  StakeAssertion,\n  StakeAssertionArgs,\n  StakeStateType,\n  StakeStateTypeArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n  getMetaAssertionDecoder,\n  getMetaAssertionEncoder,\n  getStakeAssertionDecoder,\n  getStakeAssertionEncoder,\n  getStakeStateTypeDecoder,\n  getStakeStateTypeEncoder,\n} from '.';\n\nexport type StakeAccountAssertion =\n  | { __kind: 'State'; value: StakeStateType; operator: EquatableOperator }\n  | { __kind: 'MetaAssertion'; fields: [MetaAssertion] }\n  | { __kind: 'StakeAssertion'; fields: [StakeAssertion] }\n  | { __kind: 'StakeFlags'; value: number; operator: IntegerOperator };\n\nexport type StakeAccountAssertionArgs =\n  | {\n      __kind: 'State';\n      value: StakeStateTypeArgs;\n      operator: EquatableOperatorArgs;\n    }\n  | { __kind: 'MetaAssertion'; fields: [MetaAssertionArgs] }\n  | { __kind: 'StakeAssertion'; fields: [StakeAssertionArgs] }\n  | { __kind: 'StakeFlags'; value: number; operator: IntegerOperatorArgs };\n\nexport function getStakeAccountAssertionEncoder(): Encoder<StakeAccountAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'State',\n      getStructEncoder([\n        ['value', getStakeStateTypeEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'MetaAssertion',\n      getStructEncoder([\n        ['fields', getTupleEncoder([getMetaAssertionEncoder()])],\n      ]),\n    ],\n    [\n      'StakeAssertion',\n      getStructEncoder([\n        ['fields', getTupleEncoder([getStakeAssertionEncoder()])],\n      ]),\n    ],\n    [\n      'StakeFlags',\n      getStructEncoder([\n        ['value', getU8Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getStakeAccountAssertionDecoder(): Decoder<StakeAccountAssertion> {\n  return getDataEnumDecoder([\n    [\n      'State',\n      getStructDecoder([\n        ['value', getStakeStateTypeDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'MetaAssertion',\n      getStructDecoder([\n        ['fields', getTupleDecoder([getMetaAssertionDecoder()])],\n      ]),\n    ],\n    [\n      'StakeAssertion',\n      getStructDecoder([\n        ['fields', getTupleDecoder([getStakeAssertionDecoder()])],\n      ]),\n    ],\n    [\n      'StakeFlags',\n      getStructDecoder([\n        ['value', getU8Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getStakeAccountAssertionCodec(): Codec<\n  StakeAccountAssertionArgs,\n  StakeAccountAssertion\n> {\n  return combineCodec(\n    getStakeAccountAssertionEncoder(),\n    getStakeAccountAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function stakeAccountAssertion(\n  kind: 'State',\n  data: GetDataEnumKindContent<StakeAccountAssertionArgs, 'State'>\n): GetDataEnumKind<StakeAccountAssertionArgs, 'State'>;\nexport function stakeAccountAssertion(\n  kind: 'MetaAssertion',\n  data: GetDataEnumKindContent<\n    StakeAccountAssertionArgs,\n    'MetaAssertion'\n  >['fields']\n): GetDataEnumKind<StakeAccountAssertionArgs, 'MetaAssertion'>;\nexport function stakeAccountAssertion(\n  kind: 'StakeAssertion',\n  data: GetDataEnumKindContent<\n    StakeAccountAssertionArgs,\n    'StakeAssertion'\n  >['fields']\n): GetDataEnumKind<StakeAccountAssertionArgs, 'StakeAssertion'>;\nexport function stakeAccountAssertion(\n  kind: 'StakeFlags',\n  data: GetDataEnumKindContent<StakeAccountAssertionArgs, 'StakeFlags'>\n): GetDataEnumKind<StakeAccountAssertionArgs, 'StakeFlags'>;\nexport function stakeAccountAssertion<\n  K extends StakeAccountAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<StakeAccountAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isStakeAccountAssertion<\n  K extends StakeAccountAssertion['__kind']\n>(\n  kind: K,\n  value: StakeAccountAssertion\n): value is StakeAccountAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type StakeAssertion =\n  | {\n      __kind: 'DelegationVoterPubkey';\n      value: Address;\n      operator: EquatableOperator;\n    }\n  | { __kind: 'DelegationStake'; value: bigint; operator: IntegerOperator }\n  | {\n      __kind: 'DelegationActivationEpoch';\n      value: bigint;\n      operator: IntegerOperator;\n    }\n  | {\n      __kind: 'DelegationDeactivationEpoch';\n      value: bigint;\n      operator: IntegerOperator;\n    }\n  | { __kind: 'CreditsObserved'; value: bigint; operator: IntegerOperator };\n\nexport type StakeAssertionArgs =\n  | {\n      __kind: 'DelegationVoterPubkey';\n      value: Address;\n      operator: EquatableOperatorArgs;\n    }\n  | {\n      __kind: 'DelegationStake';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'DelegationActivationEpoch';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'DelegationDeactivationEpoch';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'CreditsObserved';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    };\n\nexport function getStakeAssertionEncoder(): Encoder<StakeAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'DelegationVoterPubkey',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'DelegationStake',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'DelegationActivationEpoch',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'DelegationDeactivationEpoch',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'CreditsObserved',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getStakeAssertionDecoder(): Decoder<StakeAssertion> {\n  return getDataEnumDecoder([\n    [\n      'DelegationVoterPubkey',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'DelegationStake',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'DelegationActivationEpoch',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'DelegationDeactivationEpoch',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'CreditsObserved',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getStakeAssertionCodec(): Codec<\n  StakeAssertionArgs,\n  StakeAssertion\n> {\n  return combineCodec(getStakeAssertionEncoder(), getStakeAssertionDecoder());\n}\n\n// Data Enum Helpers.\nexport function stakeAssertion(\n  kind: 'DelegationVoterPubkey',\n  data: GetDataEnumKindContent<StakeAssertionArgs, 'DelegationVoterPubkey'>\n): GetDataEnumKind<StakeAssertionArgs, 'DelegationVoterPubkey'>;\nexport function stakeAssertion(\n  kind: 'DelegationStake',\n  data: GetDataEnumKindContent<StakeAssertionArgs, 'DelegationStake'>\n): GetDataEnumKind<StakeAssertionArgs, 'DelegationStake'>;\nexport function stakeAssertion(\n  kind: 'DelegationActivationEpoch',\n  data: GetDataEnumKindContent<StakeAssertionArgs, 'DelegationActivationEpoch'>\n): GetDataEnumKind<StakeAssertionArgs, 'DelegationActivationEpoch'>;\nexport function stakeAssertion(\n  kind: 'DelegationDeactivationEpoch',\n  data: GetDataEnumKindContent<\n    StakeAssertionArgs,\n    'DelegationDeactivationEpoch'\n  >\n): GetDataEnumKind<StakeAssertionArgs, 'DelegationDeactivationEpoch'>;\nexport function stakeAssertion(\n  kind: 'CreditsObserved',\n  data: GetDataEnumKindContent<StakeAssertionArgs, 'CreditsObserved'>\n): GetDataEnumKind<StakeAssertionArgs, 'CreditsObserved'>;\nexport function stakeAssertion<K extends StakeAssertionArgs['__kind']>(\n  kind: K,\n  data?: any\n): Extract<StakeAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isStakeAssertion<K extends StakeAssertion['__kind']>(\n  kind: K,\n  value: StakeAssertion\n): value is StakeAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum StakeStateType {\n  Uninitialized,\n  Initialized,\n  Stake,\n  RewardsPool,\n}\n\nexport type StakeStateTypeArgs = StakeStateType;\n\nexport function getStakeStateTypeEncoder(): Encoder<StakeStateTypeArgs> {\n  return getScalarEnumEncoder(StakeStateType);\n}\n\nexport function getStakeStateTypeDecoder(): Decoder<StakeStateType> {\n  return getScalarEnumDecoder(StakeStateType);\n}\n\nexport function getStakeStateTypeCodec(): Codec<\n  StakeStateTypeArgs,\n  StakeStateType\n> {\n  return combineCodec(getStakeStateTypeEncoder(), getStakeStateTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getI64Decoder,\n  getI64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n} from '@solana/codecs';\nimport {\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type SysvarClockAssertion =\n  | { __kind: 'Slot'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'EpochStartTimestamp'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'Epoch'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'LeaderScheduleEpoch'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'UnixTimestamp'; value: bigint; operator: IntegerOperator };\n\nexport type SysvarClockAssertionArgs =\n  | { __kind: 'Slot'; value: number | bigint; operator: IntegerOperatorArgs }\n  | {\n      __kind: 'EpochStartTimestamp';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | { __kind: 'Epoch'; value: number | bigint; operator: IntegerOperatorArgs }\n  | {\n      __kind: 'LeaderScheduleEpoch';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'UnixTimestamp';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    };\n\nexport function getSysvarClockAssertionEncoder(): Encoder<SysvarClockAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'Slot',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'EpochStartTimestamp',\n      getStructEncoder([\n        ['value', getI64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Epoch',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'LeaderScheduleEpoch',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'UnixTimestamp',\n      getStructEncoder([\n        ['value', getI64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getSysvarClockAssertionDecoder(): Decoder<SysvarClockAssertion> {\n  return getDataEnumDecoder([\n    [\n      'Slot',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'EpochStartTimestamp',\n      getStructDecoder([\n        ['value', getI64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Epoch',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'LeaderScheduleEpoch',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'UnixTimestamp',\n      getStructDecoder([\n        ['value', getI64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getSysvarClockAssertionCodec(): Codec<\n  SysvarClockAssertionArgs,\n  SysvarClockAssertion\n> {\n  return combineCodec(\n    getSysvarClockAssertionEncoder(),\n    getSysvarClockAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function sysvarClockAssertion(\n  kind: 'Slot',\n  data: GetDataEnumKindContent<SysvarClockAssertionArgs, 'Slot'>\n): GetDataEnumKind<SysvarClockAssertionArgs, 'Slot'>;\nexport function sysvarClockAssertion(\n  kind: 'EpochStartTimestamp',\n  data: GetDataEnumKindContent<SysvarClockAssertionArgs, 'EpochStartTimestamp'>\n): GetDataEnumKind<SysvarClockAssertionArgs, 'EpochStartTimestamp'>;\nexport function sysvarClockAssertion(\n  kind: 'Epoch',\n  data: GetDataEnumKindContent<SysvarClockAssertionArgs, 'Epoch'>\n): GetDataEnumKind<SysvarClockAssertionArgs, 'Epoch'>;\nexport function sysvarClockAssertion(\n  kind: 'LeaderScheduleEpoch',\n  data: GetDataEnumKindContent<SysvarClockAssertionArgs, 'LeaderScheduleEpoch'>\n): GetDataEnumKind<SysvarClockAssertionArgs, 'LeaderScheduleEpoch'>;\nexport function sysvarClockAssertion(\n  kind: 'UnixTimestamp',\n  data: GetDataEnumKindContent<SysvarClockAssertionArgs, 'UnixTimestamp'>\n): GetDataEnumKind<SysvarClockAssertionArgs, 'UnixTimestamp'>;\nexport function sysvarClockAssertion<\n  K extends SysvarClockAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<SysvarClockAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isSysvarClockAssertion<\n  K extends SysvarClockAssertion['__kind']\n>(\n  kind: K,\n  value: SysvarClockAssertion\n): value is SysvarClockAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  Option,\n  OptionOrNullable,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type TokenAccountAssertion =\n  | { __kind: 'Mint'; value: Address; operator: EquatableOperator }\n  | { __kind: 'Owner'; value: Address; operator: EquatableOperator }\n  | { __kind: 'Amount'; value: bigint; operator: IntegerOperator }\n  | { __kind: 'Delegate'; value: Option<Address>; operator: EquatableOperator }\n  | { __kind: 'State'; value: number; operator: IntegerOperator }\n  | { __kind: 'IsNative'; value: Option<bigint>; operator: EquatableOperator }\n  | { __kind: 'DelegatedAmount'; value: bigint; operator: IntegerOperator }\n  | {\n      __kind: 'CloseAuthority';\n      value: Option<Address>;\n      operator: EquatableOperator;\n    }\n  | { __kind: 'TokenAccountOwnerIsDerived' };\n\nexport type TokenAccountAssertionArgs =\n  | { __kind: 'Mint'; value: Address; operator: EquatableOperatorArgs }\n  | { __kind: 'Owner'; value: Address; operator: EquatableOperatorArgs }\n  | { __kind: 'Amount'; value: number | bigint; operator: IntegerOperatorArgs }\n  | {\n      __kind: 'Delegate';\n      value: OptionOrNullable<Address>;\n      operator: EquatableOperatorArgs;\n    }\n  | { __kind: 'State'; value: number; operator: IntegerOperatorArgs }\n  | {\n      __kind: 'IsNative';\n      value: OptionOrNullable<number | bigint>;\n      operator: EquatableOperatorArgs;\n    }\n  | {\n      __kind: 'DelegatedAmount';\n      value: number | bigint;\n      operator: IntegerOperatorArgs;\n    }\n  | {\n      __kind: 'CloseAuthority';\n      value: OptionOrNullable<Address>;\n      operator: EquatableOperatorArgs;\n    }\n  | { __kind: 'TokenAccountOwnerIsDerived' };\n\nexport function getTokenAccountAssertionEncoder(): Encoder<TokenAccountAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'Mint',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Owner',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Amount',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Delegate',\n      getStructEncoder([\n        ['value', getOptionEncoder(getAddressEncoder())],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'State',\n      getStructEncoder([\n        ['value', getU8Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'IsNative',\n      getStructEncoder([\n        ['value', getOptionEncoder(getU64Encoder())],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'DelegatedAmount',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n    [\n      'CloseAuthority',\n      getStructEncoder([\n        ['value', getOptionEncoder(getAddressEncoder())],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    ['TokenAccountOwnerIsDerived', getUnitEncoder()],\n  ]);\n}\n\nexport function getTokenAccountAssertionDecoder(): Decoder<TokenAccountAssertion> {\n  return getDataEnumDecoder([\n    [\n      'Mint',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Owner',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Amount',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Delegate',\n      getStructDecoder([\n        ['value', getOptionDecoder(getAddressDecoder())],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'State',\n      getStructDecoder([\n        ['value', getU8Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'IsNative',\n      getStructDecoder([\n        ['value', getOptionDecoder(getU64Decoder())],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'DelegatedAmount',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n    [\n      'CloseAuthority',\n      getStructDecoder([\n        ['value', getOptionDecoder(getAddressDecoder())],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    ['TokenAccountOwnerIsDerived', getUnitDecoder()],\n  ]);\n}\n\nexport function getTokenAccountAssertionCodec(): Codec<\n  TokenAccountAssertionArgs,\n  TokenAccountAssertion\n> {\n  return combineCodec(\n    getTokenAccountAssertionEncoder(),\n    getTokenAccountAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function tokenAccountAssertion(\n  kind: 'Mint',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'Mint'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'Mint'>;\nexport function tokenAccountAssertion(\n  kind: 'Owner',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'Owner'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'Owner'>;\nexport function tokenAccountAssertion(\n  kind: 'Amount',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'Amount'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'Amount'>;\nexport function tokenAccountAssertion(\n  kind: 'Delegate',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'Delegate'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'Delegate'>;\nexport function tokenAccountAssertion(\n  kind: 'State',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'State'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'State'>;\nexport function tokenAccountAssertion(\n  kind: 'IsNative',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'IsNative'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'IsNative'>;\nexport function tokenAccountAssertion(\n  kind: 'DelegatedAmount',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'DelegatedAmount'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'DelegatedAmount'>;\nexport function tokenAccountAssertion(\n  kind: 'CloseAuthority',\n  data: GetDataEnumKindContent<TokenAccountAssertionArgs, 'CloseAuthority'>\n): GetDataEnumKind<TokenAccountAssertionArgs, 'CloseAuthority'>;\nexport function tokenAccountAssertion(\n  kind: 'TokenAccountOwnerIsDerived'\n): GetDataEnumKind<TokenAccountAssertionArgs, 'TokenAccountOwnerIsDerived'>;\nexport function tokenAccountAssertion<\n  K extends TokenAccountAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<TokenAccountAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isTokenAccountAssertion<\n  K extends TokenAccountAssertion['__kind']\n>(\n  kind: K,\n  value: TokenAccountAssertion\n): value is TokenAccountAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  Option,\n  OptionOrNullable,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n} from '.';\n\nexport type UpgradableBufferAssertion = {\n  __kind: 'Authority';\n  value: Option<Address>;\n  operator: EquatableOperator;\n};\n\nexport type UpgradableBufferAssertionArgs = {\n  __kind: 'Authority';\n  value: OptionOrNullable<Address>;\n  operator: EquatableOperatorArgs;\n};\n\nexport function getUpgradableBufferAssertionEncoder(): Encoder<UpgradableBufferAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'Authority',\n      getStructEncoder([\n        ['value', getOptionEncoder(getAddressEncoder())],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradableBufferAssertionDecoder(): Decoder<UpgradableBufferAssertion> {\n  return getDataEnumDecoder([\n    [\n      'Authority',\n      getStructDecoder([\n        ['value', getOptionDecoder(getAddressDecoder())],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradableBufferAssertionCodec(): Codec<\n  UpgradableBufferAssertionArgs,\n  UpgradableBufferAssertion\n> {\n  return combineCodec(\n    getUpgradableBufferAssertionEncoder(),\n    getUpgradableBufferAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function upgradableBufferAssertion(\n  kind: 'Authority',\n  data: GetDataEnumKindContent<UpgradableBufferAssertionArgs, 'Authority'>\n): GetDataEnumKind<UpgradableBufferAssertionArgs, 'Authority'>;\nexport function upgradableBufferAssertion<\n  K extends UpgradableBufferAssertionArgs['__kind']\n>(kind: K, data?: any): Extract<UpgradableBufferAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isUpgradableBufferAssertion<\n  K extends UpgradableBufferAssertion['__kind']\n>(\n  kind: K,\n  value: UpgradableBufferAssertion\n): value is UpgradableBufferAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  UpgradableBufferAssertion,\n  UpgradableBufferAssertionArgs,\n  UpgradeableLoaderStateType,\n  UpgradeableLoaderStateTypeArgs,\n  UpgradeableProgramAssertion,\n  UpgradeableProgramAssertionArgs,\n  UpgradeableProgramDataAssertion,\n  UpgradeableProgramDataAssertionArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getUpgradableBufferAssertionDecoder,\n  getUpgradableBufferAssertionEncoder,\n  getUpgradeableLoaderStateTypeDecoder,\n  getUpgradeableLoaderStateTypeEncoder,\n  getUpgradeableProgramAssertionDecoder,\n  getUpgradeableProgramAssertionEncoder,\n  getUpgradeableProgramDataAssertionDecoder,\n  getUpgradeableProgramDataAssertionEncoder,\n} from '.';\n\nexport type UpgradeableLoaderStateAssertion =\n  | {\n      __kind: 'State';\n      value: UpgradeableLoaderStateType;\n      operator: EquatableOperator;\n    }\n  | { __kind: 'Buffer'; fields: [UpgradableBufferAssertion] }\n  | { __kind: 'Program'; fields: [UpgradeableProgramAssertion] }\n  | { __kind: 'ProgramData'; fields: [UpgradeableProgramDataAssertion] };\n\nexport type UpgradeableLoaderStateAssertionArgs =\n  | {\n      __kind: 'State';\n      value: UpgradeableLoaderStateTypeArgs;\n      operator: EquatableOperatorArgs;\n    }\n  | { __kind: 'Buffer'; fields: [UpgradableBufferAssertionArgs] }\n  | { __kind: 'Program'; fields: [UpgradeableProgramAssertionArgs] }\n  | { __kind: 'ProgramData'; fields: [UpgradeableProgramDataAssertionArgs] };\n\nexport function getUpgradeableLoaderStateAssertionEncoder(): Encoder<UpgradeableLoaderStateAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'State',\n      getStructEncoder([\n        ['value', getUpgradeableLoaderStateTypeEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Buffer',\n      getStructEncoder([\n        ['fields', getTupleEncoder([getUpgradableBufferAssertionEncoder()])],\n      ]),\n    ],\n    [\n      'Program',\n      getStructEncoder([\n        ['fields', getTupleEncoder([getUpgradeableProgramAssertionEncoder()])],\n      ]),\n    ],\n    [\n      'ProgramData',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([getUpgradeableProgramDataAssertionEncoder()]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradeableLoaderStateAssertionDecoder(): Decoder<UpgradeableLoaderStateAssertion> {\n  return getDataEnumDecoder([\n    [\n      'State',\n      getStructDecoder([\n        ['value', getUpgradeableLoaderStateTypeDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Buffer',\n      getStructDecoder([\n        ['fields', getTupleDecoder([getUpgradableBufferAssertionDecoder()])],\n      ]),\n    ],\n    [\n      'Program',\n      getStructDecoder([\n        ['fields', getTupleDecoder([getUpgradeableProgramAssertionDecoder()])],\n      ]),\n    ],\n    [\n      'ProgramData',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([getUpgradeableProgramDataAssertionDecoder()]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradeableLoaderStateAssertionCodec(): Codec<\n  UpgradeableLoaderStateAssertionArgs,\n  UpgradeableLoaderStateAssertion\n> {\n  return combineCodec(\n    getUpgradeableLoaderStateAssertionEncoder(),\n    getUpgradeableLoaderStateAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function upgradeableLoaderStateAssertion(\n  kind: 'State',\n  data: GetDataEnumKindContent<UpgradeableLoaderStateAssertionArgs, 'State'>\n): GetDataEnumKind<UpgradeableLoaderStateAssertionArgs, 'State'>;\nexport function upgradeableLoaderStateAssertion(\n  kind: 'Buffer',\n  data: GetDataEnumKindContent<\n    UpgradeableLoaderStateAssertionArgs,\n    'Buffer'\n  >['fields']\n): GetDataEnumKind<UpgradeableLoaderStateAssertionArgs, 'Buffer'>;\nexport function upgradeableLoaderStateAssertion(\n  kind: 'Program',\n  data: GetDataEnumKindContent<\n    UpgradeableLoaderStateAssertionArgs,\n    'Program'\n  >['fields']\n): GetDataEnumKind<UpgradeableLoaderStateAssertionArgs, 'Program'>;\nexport function upgradeableLoaderStateAssertion(\n  kind: 'ProgramData',\n  data: GetDataEnumKindContent<\n    UpgradeableLoaderStateAssertionArgs,\n    'ProgramData'\n  >['fields']\n): GetDataEnumKind<UpgradeableLoaderStateAssertionArgs, 'ProgramData'>;\nexport function upgradeableLoaderStateAssertion<\n  K extends UpgradeableLoaderStateAssertionArgs['__kind']\n>(\n  kind: K,\n  data?: any\n): Extract<UpgradeableLoaderStateAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isUpgradeableLoaderStateAssertion<\n  K extends UpgradeableLoaderStateAssertion['__kind']\n>(\n  kind: K,\n  value: UpgradeableLoaderStateAssertion\n): value is UpgradeableLoaderStateAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getScalarEnumDecoder,\n  getScalarEnumEncoder,\n} from '@solana/codecs';\n\nexport enum UpgradeableLoaderStateType {\n  Uninitialized,\n  Buffer,\n  Program,\n  ProgramData,\n}\n\nexport type UpgradeableLoaderStateTypeArgs = UpgradeableLoaderStateType;\n\nexport function getUpgradeableLoaderStateTypeEncoder(): Encoder<UpgradeableLoaderStateTypeArgs> {\n  return getScalarEnumEncoder(UpgradeableLoaderStateType);\n}\n\nexport function getUpgradeableLoaderStateTypeDecoder(): Decoder<UpgradeableLoaderStateType> {\n  return getScalarEnumDecoder(UpgradeableLoaderStateType);\n}\n\nexport function getUpgradeableLoaderStateTypeCodec(): Codec<\n  UpgradeableLoaderStateTypeArgs,\n  UpgradeableLoaderStateType\n> {\n  return combineCodec(\n    getUpgradeableLoaderStateTypeEncoder(),\n    getUpgradeableLoaderStateTypeDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getStructDecoder,\n  getStructEncoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n} from '.';\n\nexport type UpgradeableProgramAssertion = {\n  __kind: 'ProgramDataAddress';\n  value: Address;\n  operator: EquatableOperator;\n};\n\nexport type UpgradeableProgramAssertionArgs = {\n  __kind: 'ProgramDataAddress';\n  value: Address;\n  operator: EquatableOperatorArgs;\n};\n\nexport function getUpgradeableProgramAssertionEncoder(): Encoder<UpgradeableProgramAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'ProgramDataAddress',\n      getStructEncoder([\n        ['value', getAddressEncoder()],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradeableProgramAssertionDecoder(): Decoder<UpgradeableProgramAssertion> {\n  return getDataEnumDecoder([\n    [\n      'ProgramDataAddress',\n      getStructDecoder([\n        ['value', getAddressDecoder()],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradeableProgramAssertionCodec(): Codec<\n  UpgradeableProgramAssertionArgs,\n  UpgradeableProgramAssertion\n> {\n  return combineCodec(\n    getUpgradeableProgramAssertionEncoder(),\n    getUpgradeableProgramAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function upgradeableProgramAssertion(\n  kind: 'ProgramDataAddress',\n  data: GetDataEnumKindContent<\n    UpgradeableProgramAssertionArgs,\n    'ProgramDataAddress'\n  >\n): GetDataEnumKind<UpgradeableProgramAssertionArgs, 'ProgramDataAddress'>;\nexport function upgradeableProgramAssertion<\n  K extends UpgradeableProgramAssertionArgs['__kind']\n>(\n  kind: K,\n  data?: any\n): Extract<UpgradeableProgramAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isUpgradeableProgramAssertion<\n  K extends UpgradeableProgramAssertion['__kind']\n>(\n  kind: K,\n  value: UpgradeableProgramAssertion\n): value is UpgradeableProgramAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  getAddressDecoder,\n  getAddressEncoder,\n} from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  Option,\n  OptionOrNullable,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n} from '@solana/codecs';\nimport {\n  EquatableOperator,\n  EquatableOperatorArgs,\n  IntegerOperator,\n  IntegerOperatorArgs,\n  getEquatableOperatorDecoder,\n  getEquatableOperatorEncoder,\n  getIntegerOperatorDecoder,\n  getIntegerOperatorEncoder,\n} from '.';\n\nexport type UpgradeableProgramDataAssertion =\n  | {\n      __kind: 'UpgradeAuthority';\n      value: Option<Address>;\n      operator: EquatableOperator;\n    }\n  | { __kind: 'Slot'; value: bigint; operator: IntegerOperator };\n\nexport type UpgradeableProgramDataAssertionArgs =\n  | {\n      __kind: 'UpgradeAuthority';\n      value: OptionOrNullable<Address>;\n      operator: EquatableOperatorArgs;\n    }\n  | { __kind: 'Slot'; value: number | bigint; operator: IntegerOperatorArgs };\n\nexport function getUpgradeableProgramDataAssertionEncoder(): Encoder<UpgradeableProgramDataAssertionArgs> {\n  return getDataEnumEncoder([\n    [\n      'UpgradeAuthority',\n      getStructEncoder([\n        ['value', getOptionEncoder(getAddressEncoder())],\n        ['operator', getEquatableOperatorEncoder()],\n      ]),\n    ],\n    [\n      'Slot',\n      getStructEncoder([\n        ['value', getU64Encoder()],\n        ['operator', getIntegerOperatorEncoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradeableProgramDataAssertionDecoder(): Decoder<UpgradeableProgramDataAssertion> {\n  return getDataEnumDecoder([\n    [\n      'UpgradeAuthority',\n      getStructDecoder([\n        ['value', getOptionDecoder(getAddressDecoder())],\n        ['operator', getEquatableOperatorDecoder()],\n      ]),\n    ],\n    [\n      'Slot',\n      getStructDecoder([\n        ['value', getU64Decoder()],\n        ['operator', getIntegerOperatorDecoder()],\n      ]),\n    ],\n  ]);\n}\n\nexport function getUpgradeableProgramDataAssertionCodec(): Codec<\n  UpgradeableProgramDataAssertionArgs,\n  UpgradeableProgramDataAssertion\n> {\n  return combineCodec(\n    getUpgradeableProgramDataAssertionEncoder(),\n    getUpgradeableProgramDataAssertionDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function upgradeableProgramDataAssertion(\n  kind: 'UpgradeAuthority',\n  data: GetDataEnumKindContent<\n    UpgradeableProgramDataAssertionArgs,\n    'UpgradeAuthority'\n  >\n): GetDataEnumKind<UpgradeableProgramDataAssertionArgs, 'UpgradeAuthority'>;\nexport function upgradeableProgramDataAssertion(\n  kind: 'Slot',\n  data: GetDataEnumKindContent<UpgradeableProgramDataAssertionArgs, 'Slot'>\n): GetDataEnumKind<UpgradeableProgramDataAssertionArgs, 'Slot'>;\nexport function upgradeableProgramDataAssertion<\n  K extends UpgradeableProgramDataAssertionArgs['__kind']\n>(\n  kind: K,\n  data?: any\n): Extract<UpgradeableProgramDataAssertionArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isUpgradeableProgramDataAssertion<\n  K extends UpgradeableProgramDataAssertion['__kind']\n>(\n  kind: K,\n  value: UpgradeableProgramDataAssertion\n): value is UpgradeableProgramDataAssertion & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  GetDataEnumKind,\n  GetDataEnumKindContent,\n  combineCodec,\n  getDataEnumDecoder,\n  getDataEnumEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU16Decoder,\n  getU16Encoder,\n} from '@solana/codecs';\nimport {\n  AccountInfoField,\n  AccountInfoFieldArgs,\n  ClockField,\n  ClockFieldArgs,\n  DataValue,\n  DataValueArgs,\n  getAccountInfoFieldDecoder,\n  getAccountInfoFieldEncoder,\n  getClockFieldDecoder,\n  getClockFieldEncoder,\n  getDataValueDecoder,\n  getDataValueEncoder,\n} from '.';\n\nexport type WriteType =\n  | { __kind: 'AccountData'; offset: number; dataLength: number }\n  | { __kind: 'AccountInfoField'; fields: [AccountInfoField] }\n  | { __kind: 'DataValue'; fields: [DataValue] }\n  | { __kind: 'Clock'; fields: [ClockField] };\n\nexport type WriteTypeArgs =\n  | { __kind: 'AccountData'; offset: number; dataLength: number }\n  | { __kind: 'AccountInfoField'; fields: [AccountInfoFieldArgs] }\n  | { __kind: 'DataValue'; fields: [DataValueArgs] }\n  | { __kind: 'Clock'; fields: [ClockFieldArgs] };\n\nexport function getWriteTypeEncoder(): Encoder<WriteTypeArgs> {\n  return getDataEnumEncoder([\n    [\n      'AccountData',\n      getStructEncoder([\n        ['offset', getU16Encoder()],\n        ['dataLength', getU16Encoder()],\n      ]),\n    ],\n    [\n      'AccountInfoField',\n      getStructEncoder([\n        ['fields', getTupleEncoder([getAccountInfoFieldEncoder()])],\n      ]),\n    ],\n    [\n      'DataValue',\n      getStructEncoder([['fields', getTupleEncoder([getDataValueEncoder()])]]),\n    ],\n    [\n      'Clock',\n      getStructEncoder([['fields', getTupleEncoder([getClockFieldEncoder()])]]),\n    ],\n  ]);\n}\n\nexport function getWriteTypeDecoder(): Decoder<WriteType> {\n  return getDataEnumDecoder([\n    [\n      'AccountData',\n      getStructDecoder([\n        ['offset', getU16Decoder()],\n        ['dataLength', getU16Decoder()],\n      ]),\n    ],\n    [\n      'AccountInfoField',\n      getStructDecoder([\n        ['fields', getTupleDecoder([getAccountInfoFieldDecoder()])],\n      ]),\n    ],\n    [\n      'DataValue',\n      getStructDecoder([['fields', getTupleDecoder([getDataValueDecoder()])]]),\n    ],\n    [\n      'Clock',\n      getStructDecoder([['fields', getTupleDecoder([getClockFieldDecoder()])]]),\n    ],\n  ]);\n}\n\nexport function getWriteTypeCodec(): Codec<WriteTypeArgs, WriteType> {\n  return combineCodec(getWriteTypeEncoder(), getWriteTypeDecoder());\n}\n\n// Data Enum Helpers.\nexport function writeType(\n  kind: 'AccountData',\n  data: GetDataEnumKindContent<WriteTypeArgs, 'AccountData'>\n): GetDataEnumKind<WriteTypeArgs, 'AccountData'>;\nexport function writeType(\n  kind: 'AccountInfoField',\n  data: GetDataEnumKindContent<WriteTypeArgs, 'AccountInfoField'>['fields']\n): GetDataEnumKind<WriteTypeArgs, 'AccountInfoField'>;\nexport function writeType(\n  kind: 'DataValue',\n  data: GetDataEnumKindContent<WriteTypeArgs, 'DataValue'>['fields']\n): GetDataEnumKind<WriteTypeArgs, 'DataValue'>;\nexport function writeType(\n  kind: 'Clock',\n  data: GetDataEnumKindContent<WriteTypeArgs, 'Clock'>['fields']\n): GetDataEnumKind<WriteTypeArgs, 'Clock'>;\nexport function writeType<K extends WriteTypeArgs['__kind']>(\n  kind: K,\n  data?: any\n): Extract<WriteTypeArgs, { __kind: K }> {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isWriteType<K extends WriteType['__kind']>(\n  kind: K,\n  value: WriteType\n): value is WriteType & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  AccountDeltaAssertion,\n  AccountDeltaAssertionArgs,\n  LogLevel,\n  LogLevelArgs,\n  getAccountDeltaAssertionDecoder,\n  getAccountDeltaAssertionEncoder,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n} from '../types';\n\nexport type AssertAccountDeltaInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountAccountA extends string | IAccountMeta<string> = string,\n  TAccountAccountB extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccountA extends string\n        ? ReadonlyAccount<TAccountAccountA>\n        : TAccountAccountA,\n      TAccountAccountB extends string\n        ? ReadonlyAccount<TAccountAccountB>\n        : TAccountAccountB,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountDeltaInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountAccountA extends string | IAccountMeta<string> = string,\n  TAccountAccountB extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccountA extends string\n        ? ReadonlyAccount<TAccountAccountA>\n        : TAccountAccountA,\n      TAccountAccountB extends string\n        ? ReadonlyAccount<TAccountAccountB>\n        : TAccountAccountB,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountDeltaInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: AccountDeltaAssertion;\n};\n\nexport type AssertAccountDeltaInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: AccountDeltaAssertionArgs;\n};\n\nexport function getAssertAccountDeltaInstructionDataEncoder(): Encoder<AssertAccountDeltaInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getAccountDeltaAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 3,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertAccountDeltaInstructionDataDecoder(): Decoder<AssertAccountDeltaInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getAccountDeltaAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertAccountDeltaInstructionDataCodec(): Codec<\n  AssertAccountDeltaInstructionDataArgs,\n  AssertAccountDeltaInstructionData\n> {\n  return combineCodec(\n    getAssertAccountDeltaInstructionDataEncoder(),\n    getAssertAccountDeltaInstructionDataDecoder()\n  );\n}\n\nexport type AssertAccountDeltaInput<\n  TAccountAccountA extends string,\n  TAccountAccountB extends string\n> = {\n  /** Account A where the delta is calculated from */\n  accountA: Address<TAccountAccountA>;\n  /** Account B where the delta is calculated to */\n  accountB: Address<TAccountAccountB>;\n  logLevel?: AssertAccountDeltaInstructionDataArgs['logLevel'];\n  assertion: AssertAccountDeltaInstructionDataArgs['assertion'];\n};\n\nexport type AssertAccountDeltaInputWithSigners<\n  TAccountAccountA extends string,\n  TAccountAccountB extends string\n> = {\n  /** Account A where the delta is calculated from */\n  accountA: Address<TAccountAccountA>;\n  /** Account B where the delta is calculated to */\n  accountB: Address<TAccountAccountB>;\n  logLevel?: AssertAccountDeltaInstructionDataArgs['logLevel'];\n  assertion: AssertAccountDeltaInstructionDataArgs['assertion'];\n};\n\nexport function getAssertAccountDeltaInstruction<\n  TAccountAccountA extends string,\n  TAccountAccountB extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountDeltaInputWithSigners<TAccountAccountA, TAccountAccountB>\n): AssertAccountDeltaInstructionWithSigners<\n  TProgram,\n  TAccountAccountA,\n  TAccountAccountB\n>;\nexport function getAssertAccountDeltaInstruction<\n  TAccountAccountA extends string,\n  TAccountAccountB extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountDeltaInput<TAccountAccountA, TAccountAccountB>\n): AssertAccountDeltaInstruction<TProgram, TAccountAccountA, TAccountAccountB>;\nexport function getAssertAccountDeltaInstruction<\n  TAccountAccountA extends string,\n  TAccountAccountB extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountDeltaInput<TAccountAccountA, TAccountAccountB>\n): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertAccountDeltaInstructionRaw<\n      TProgram,\n      TAccountAccountA,\n      TAccountAccountB\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    accountA: { value: input.accountA ?? null, isWritable: false },\n    accountB: { value: input.accountB ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertAccountDeltaInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertAccountDeltaInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertAccountDeltaInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountAccountA extends string | IAccountMeta<string> = string,\n  TAccountAccountB extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    accountA: TAccountAccountA extends string\n      ? Address<TAccountAccountA>\n      : TAccountAccountA;\n    accountB: TAccountAccountB extends string\n      ? Address<TAccountAccountB>\n      : TAccountAccountB;\n  },\n  args: AssertAccountDeltaInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.accountA, AccountRole.READONLY),\n      accountMetaWithDefault(accounts.accountB, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertAccountDeltaInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertAccountDeltaInstruction<\n    TProgram,\n    TAccountAccountA,\n    TAccountAccountB,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertAccountDeltaInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Account A where the delta is calculated from */\n    accountA: TAccountMetas[0];\n    /** Account B where the delta is calculated to */\n    accountB: TAccountMetas[1];\n  };\n  data: AssertAccountDeltaInstructionData;\n};\n\nexport function parseAssertAccountDeltaInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertAccountDeltaInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      accountA: getNextAccount(),\n      accountB: getNextAccount(),\n    },\n    data: getAssertAccountDeltaInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  AccountInfoAssertion,\n  AccountInfoAssertionArgs,\n  LogLevel,\n  LogLevelArgs,\n  getAccountInfoAssertionDecoder,\n  getAccountInfoAssertionEncoder,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n} from '../types';\n\nexport type AssertAccountInfoInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountInfoInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountInfoInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: AccountInfoAssertion;\n};\n\nexport type AssertAccountInfoInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: AccountInfoAssertionArgs;\n};\n\nexport function getAssertAccountInfoInstructionDataEncoder(): Encoder<AssertAccountInfoInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getAccountInfoAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 4,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertAccountInfoInstructionDataDecoder(): Decoder<AssertAccountInfoInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getAccountInfoAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertAccountInfoInstructionDataCodec(): Codec<\n  AssertAccountInfoInstructionDataArgs,\n  AssertAccountInfoInstructionData\n> {\n  return combineCodec(\n    getAssertAccountInfoInstructionDataEncoder(),\n    getAssertAccountInfoInstructionDataDecoder()\n  );\n}\n\nexport type AssertAccountInfoInput<TAccountTargetAccount extends string> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertAccountInfoInstructionDataArgs['logLevel'];\n  assertion: AssertAccountInfoInstructionDataArgs['assertion'];\n};\n\nexport type AssertAccountInfoInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertAccountInfoInstructionDataArgs['logLevel'];\n  assertion: AssertAccountInfoInstructionDataArgs['assertion'];\n};\n\nexport function getAssertAccountInfoInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountInfoInputWithSigners<TAccountTargetAccount>\n): AssertAccountInfoInstructionWithSigners<TProgram, TAccountTargetAccount>;\nexport function getAssertAccountInfoInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountInfoInput<TAccountTargetAccount>\n): AssertAccountInfoInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertAccountInfoInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertAccountInfoInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertAccountInfoInstructionRaw<TProgram, TAccountTargetAccount>\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertAccountInfoInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertAccountInfoInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertAccountInfoInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertAccountInfoInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertAccountInfoInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertAccountInfoInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertAccountInfoInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertAccountInfoInstructionData;\n};\n\nexport function parseAssertAccountInfoInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertAccountInfoInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertAccountInfoInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  AccountInfoAssertion,\n  AccountInfoAssertionArgs,\n  LogLevel,\n  LogLevelArgs,\n  getAccountInfoAssertionDecoder,\n  getAccountInfoAssertionEncoder,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n} from '../types';\n\nexport type AssertAccountInfoMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountInfoMultiInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertAccountInfoMultiInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertions: Array<AccountInfoAssertion>;\n};\n\nexport type AssertAccountInfoMultiInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertions: Array<AccountInfoAssertionArgs>;\n};\n\nexport function getAssertAccountInfoMultiInstructionDataEncoder(): Encoder<AssertAccountInfoMultiInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertions', getArrayEncoder(getAccountInfoAssertionEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 5,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertAccountInfoMultiInstructionDataDecoder(): Decoder<AssertAccountInfoMultiInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertions', getArrayDecoder(getAccountInfoAssertionDecoder())],\n  ]);\n}\n\nexport function getAssertAccountInfoMultiInstructionDataCodec(): Codec<\n  AssertAccountInfoMultiInstructionDataArgs,\n  AssertAccountInfoMultiInstructionData\n> {\n  return combineCodec(\n    getAssertAccountInfoMultiInstructionDataEncoder(),\n    getAssertAccountInfoMultiInstructionDataDecoder()\n  );\n}\n\nexport type AssertAccountInfoMultiInput<TAccountTargetAccount extends string> =\n  {\n    /** Target account to be asserted */\n    targetAccount: Address<TAccountTargetAccount>;\n    logLevel?: AssertAccountInfoMultiInstructionDataArgs['logLevel'];\n    assertions: AssertAccountInfoMultiInstructionDataArgs['assertions'];\n  };\n\nexport type AssertAccountInfoMultiInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertAccountInfoMultiInstructionDataArgs['logLevel'];\n  assertions: AssertAccountInfoMultiInstructionDataArgs['assertions'];\n};\n\nexport function getAssertAccountInfoMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountInfoMultiInputWithSigners<TAccountTargetAccount>\n): AssertAccountInfoMultiInstructionWithSigners<\n  TProgram,\n  TAccountTargetAccount\n>;\nexport function getAssertAccountInfoMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertAccountInfoMultiInput<TAccountTargetAccount>\n): AssertAccountInfoMultiInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertAccountInfoMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertAccountInfoMultiInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertAccountInfoMultiInstructionRaw<\n      TProgram,\n      TAccountTargetAccount\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertAccountInfoMultiInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertAccountInfoMultiInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertAccountInfoMultiInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertAccountInfoMultiInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertAccountInfoMultiInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertAccountInfoMultiInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertAccountInfoMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertAccountInfoMultiInstructionData;\n};\n\nexport function parseAssertAccountInfoMultiInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertAccountInfoMultiInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertAccountInfoMultiInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  MerkleTreeAssertion,\n  MerkleTreeAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getMerkleTreeAssertionDecoder,\n  getMerkleTreeAssertionEncoder,\n} from '../types';\n\nexport type AssertMerkleTreeAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetMerkleTree extends string | IAccountMeta<string> = string,\n  TAccountRoot extends string | IAccountMeta<string> = string,\n  TAccountSplAccountCompression extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetMerkleTree extends string\n        ? ReadonlyAccount<TAccountTargetMerkleTree>\n        : TAccountTargetMerkleTree,\n      TAccountRoot extends string\n        ? ReadonlyAccount<TAccountRoot>\n        : TAccountRoot,\n      TAccountSplAccountCompression extends string\n        ? ReadonlyAccount<TAccountSplAccountCompression>\n        : TAccountSplAccountCompression,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertMerkleTreeAccountInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetMerkleTree extends string | IAccountMeta<string> = string,\n  TAccountRoot extends string | IAccountMeta<string> = string,\n  TAccountSplAccountCompression extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetMerkleTree extends string\n        ? ReadonlyAccount<TAccountTargetMerkleTree>\n        : TAccountTargetMerkleTree,\n      TAccountRoot extends string\n        ? ReadonlyAccount<TAccountRoot>\n        : TAccountRoot,\n      TAccountSplAccountCompression extends string\n        ? ReadonlyAccount<TAccountSplAccountCompression>\n        : TAccountSplAccountCompression,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertMerkleTreeAccountInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: MerkleTreeAssertion;\n};\n\nexport type AssertMerkleTreeAccountInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: MerkleTreeAssertionArgs;\n};\n\nexport function getAssertMerkleTreeAccountInstructionDataEncoder(): Encoder<AssertMerkleTreeAccountInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getMerkleTreeAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 15,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertMerkleTreeAccountInstructionDataDecoder(): Decoder<AssertMerkleTreeAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getMerkleTreeAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertMerkleTreeAccountInstructionDataCodec(): Codec<\n  AssertMerkleTreeAccountInstructionDataArgs,\n  AssertMerkleTreeAccountInstructionData\n> {\n  return combineCodec(\n    getAssertMerkleTreeAccountInstructionDataEncoder(),\n    getAssertMerkleTreeAccountInstructionDataDecoder()\n  );\n}\n\nexport type AssertMerkleTreeAccountInput<\n  TAccountTargetMerkleTree extends string,\n  TAccountRoot extends string,\n  TAccountSplAccountCompression extends string\n> = {\n  /** Target merkle tree account to be asserted */\n  targetMerkleTree: Address<TAccountTargetMerkleTree>;\n  /** The current root of the merkle tree */\n  root: Address<TAccountRoot>;\n  /** SPL account compression program */\n  splAccountCompression: Address<TAccountSplAccountCompression>;\n  logLevel?: AssertMerkleTreeAccountInstructionDataArgs['logLevel'];\n  assertion: AssertMerkleTreeAccountInstructionDataArgs['assertion'];\n};\n\nexport type AssertMerkleTreeAccountInputWithSigners<\n  TAccountTargetMerkleTree extends string,\n  TAccountRoot extends string,\n  TAccountSplAccountCompression extends string\n> = {\n  /** Target merkle tree account to be asserted */\n  targetMerkleTree: Address<TAccountTargetMerkleTree>;\n  /** The current root of the merkle tree */\n  root: Address<TAccountRoot>;\n  /** SPL account compression program */\n  splAccountCompression: Address<TAccountSplAccountCompression>;\n  logLevel?: AssertMerkleTreeAccountInstructionDataArgs['logLevel'];\n  assertion: AssertMerkleTreeAccountInstructionDataArgs['assertion'];\n};\n\nexport function getAssertMerkleTreeAccountInstruction<\n  TAccountTargetMerkleTree extends string,\n  TAccountRoot extends string,\n  TAccountSplAccountCompression extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertMerkleTreeAccountInputWithSigners<\n    TAccountTargetMerkleTree,\n    TAccountRoot,\n    TAccountSplAccountCompression\n  >\n): AssertMerkleTreeAccountInstructionWithSigners<\n  TProgram,\n  TAccountTargetMerkleTree,\n  TAccountRoot,\n  TAccountSplAccountCompression\n>;\nexport function getAssertMerkleTreeAccountInstruction<\n  TAccountTargetMerkleTree extends string,\n  TAccountRoot extends string,\n  TAccountSplAccountCompression extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertMerkleTreeAccountInput<\n    TAccountTargetMerkleTree,\n    TAccountRoot,\n    TAccountSplAccountCompression\n  >\n): AssertMerkleTreeAccountInstruction<\n  TProgram,\n  TAccountTargetMerkleTree,\n  TAccountRoot,\n  TAccountSplAccountCompression\n>;\nexport function getAssertMerkleTreeAccountInstruction<\n  TAccountTargetMerkleTree extends string,\n  TAccountRoot extends string,\n  TAccountSplAccountCompression extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertMerkleTreeAccountInput<\n    TAccountTargetMerkleTree,\n    TAccountRoot,\n    TAccountSplAccountCompression\n  >\n): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertMerkleTreeAccountInstructionRaw<\n      TProgram,\n      TAccountTargetMerkleTree,\n      TAccountRoot,\n      TAccountSplAccountCompression\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetMerkleTree: {\n      value: input.targetMerkleTree ?? null,\n      isWritable: false,\n    },\n    root: { value: input.root ?? null, isWritable: false },\n    splAccountCompression: {\n      value: input.splAccountCompression ?? null,\n      isWritable: false,\n    },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertMerkleTreeAccountInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertMerkleTreeAccountInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertMerkleTreeAccountInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetMerkleTree extends string | IAccountMeta<string> = string,\n  TAccountRoot extends string | IAccountMeta<string> = string,\n  TAccountSplAccountCompression extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetMerkleTree: TAccountTargetMerkleTree extends string\n      ? Address<TAccountTargetMerkleTree>\n      : TAccountTargetMerkleTree;\n    root: TAccountRoot extends string ? Address<TAccountRoot> : TAccountRoot;\n    splAccountCompression: TAccountSplAccountCompression extends string\n      ? Address<TAccountSplAccountCompression>\n      : TAccountSplAccountCompression;\n  },\n  args: AssertMerkleTreeAccountInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetMerkleTree, AccountRole.READONLY),\n      accountMetaWithDefault(accounts.root, AccountRole.READONLY),\n      accountMetaWithDefault(\n        accounts.splAccountCompression,\n        AccountRole.READONLY\n      ),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertMerkleTreeAccountInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertMerkleTreeAccountInstruction<\n    TProgram,\n    TAccountTargetMerkleTree,\n    TAccountRoot,\n    TAccountSplAccountCompression,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertMerkleTreeAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target merkle tree account to be asserted */\n    targetMerkleTree: TAccountMetas[0];\n    /** The current root of the merkle tree */\n    root: TAccountMetas[1];\n    /** SPL account compression program */\n    splAccountCompression: TAccountMetas[2];\n  };\n  data: AssertMerkleTreeAccountInstructionData;\n};\n\nexport function parseAssertMerkleTreeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertMerkleTreeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetMerkleTree: getNextAccount(),\n      root: getNextAccount(),\n      splAccountCompression: getNextAccount(),\n    },\n    data: getAssertMerkleTreeAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  MintAccountAssertion,\n  MintAccountAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getMintAccountAssertionDecoder,\n  getMintAccountAssertionEncoder,\n} from '../types';\n\nexport type AssertMintAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertMintAccountInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertMintAccountInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: MintAccountAssertion;\n};\n\nexport type AssertMintAccountInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: MintAccountAssertionArgs;\n};\n\nexport function getAssertMintAccountInstructionDataEncoder(): Encoder<AssertMintAccountInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getMintAccountAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 6,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertMintAccountInstructionDataDecoder(): Decoder<AssertMintAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getMintAccountAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertMintAccountInstructionDataCodec(): Codec<\n  AssertMintAccountInstructionDataArgs,\n  AssertMintAccountInstructionData\n> {\n  return combineCodec(\n    getAssertMintAccountInstructionDataEncoder(),\n    getAssertMintAccountInstructionDataDecoder()\n  );\n}\n\nexport type AssertMintAccountInput<TAccountTargetAccount extends string> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertMintAccountInstructionDataArgs['logLevel'];\n  assertion: AssertMintAccountInstructionDataArgs['assertion'];\n};\n\nexport type AssertMintAccountInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertMintAccountInstructionDataArgs['logLevel'];\n  assertion: AssertMintAccountInstructionDataArgs['assertion'];\n};\n\nexport function getAssertMintAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertMintAccountInputWithSigners<TAccountTargetAccount>\n): AssertMintAccountInstructionWithSigners<TProgram, TAccountTargetAccount>;\nexport function getAssertMintAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertMintAccountInput<TAccountTargetAccount>\n): AssertMintAccountInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertMintAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertMintAccountInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertMintAccountInstructionRaw<TProgram, TAccountTargetAccount>\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertMintAccountInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertMintAccountInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertMintAccountInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertMintAccountInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertMintAccountInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertMintAccountInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertMintAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertMintAccountInstructionData;\n};\n\nexport function parseAssertMintAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertMintAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertMintAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  MintAccountAssertion,\n  MintAccountAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getMintAccountAssertionDecoder,\n  getMintAccountAssertionEncoder,\n} from '../types';\n\nexport type AssertMintAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertMintAccountMultiInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertMintAccountMultiInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertions: Array<MintAccountAssertion>;\n};\n\nexport type AssertMintAccountMultiInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertions: Array<MintAccountAssertionArgs>;\n};\n\nexport function getAssertMintAccountMultiInstructionDataEncoder(): Encoder<AssertMintAccountMultiInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertions', getArrayEncoder(getMintAccountAssertionEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 7,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertMintAccountMultiInstructionDataDecoder(): Decoder<AssertMintAccountMultiInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertions', getArrayDecoder(getMintAccountAssertionDecoder())],\n  ]);\n}\n\nexport function getAssertMintAccountMultiInstructionDataCodec(): Codec<\n  AssertMintAccountMultiInstructionDataArgs,\n  AssertMintAccountMultiInstructionData\n> {\n  return combineCodec(\n    getAssertMintAccountMultiInstructionDataEncoder(),\n    getAssertMintAccountMultiInstructionDataDecoder()\n  );\n}\n\nexport type AssertMintAccountMultiInput<TAccountTargetAccount extends string> =\n  {\n    /** Target account to be asserted */\n    targetAccount: Address<TAccountTargetAccount>;\n    logLevel?: AssertMintAccountMultiInstructionDataArgs['logLevel'];\n    assertions: AssertMintAccountMultiInstructionDataArgs['assertions'];\n  };\n\nexport type AssertMintAccountMultiInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertMintAccountMultiInstructionDataArgs['logLevel'];\n  assertions: AssertMintAccountMultiInstructionDataArgs['assertions'];\n};\n\nexport function getAssertMintAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertMintAccountMultiInputWithSigners<TAccountTargetAccount>\n): AssertMintAccountMultiInstructionWithSigners<\n  TProgram,\n  TAccountTargetAccount\n>;\nexport function getAssertMintAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertMintAccountMultiInput<TAccountTargetAccount>\n): AssertMintAccountMultiInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertMintAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertMintAccountMultiInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertMintAccountMultiInstructionRaw<\n      TProgram,\n      TAccountTargetAccount\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertMintAccountMultiInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertMintAccountMultiInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertMintAccountMultiInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertMintAccountMultiInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertMintAccountMultiInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertMintAccountMultiInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertMintAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertMintAccountMultiInstructionData;\n};\n\nexport function parseAssertMintAccountMultiInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertMintAccountMultiInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertMintAccountMultiInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  StakeAccountAssertion,\n  StakeAccountAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getStakeAccountAssertionDecoder,\n  getStakeAccountAssertionEncoder,\n} from '../types';\n\nexport type AssertStakeAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertStakeAccountInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertStakeAccountInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: StakeAccountAssertion;\n};\n\nexport type AssertStakeAccountInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: StakeAccountAssertionArgs;\n};\n\nexport function getAssertStakeAccountInstructionDataEncoder(): Encoder<AssertStakeAccountInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getStakeAccountAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 10,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertStakeAccountInstructionDataDecoder(): Decoder<AssertStakeAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getStakeAccountAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertStakeAccountInstructionDataCodec(): Codec<\n  AssertStakeAccountInstructionDataArgs,\n  AssertStakeAccountInstructionData\n> {\n  return combineCodec(\n    getAssertStakeAccountInstructionDataEncoder(),\n    getAssertStakeAccountInstructionDataDecoder()\n  );\n}\n\nexport type AssertStakeAccountInput<TAccountTargetAccount extends string> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertStakeAccountInstructionDataArgs['logLevel'];\n  assertion: AssertStakeAccountInstructionDataArgs['assertion'];\n};\n\nexport type AssertStakeAccountInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertStakeAccountInstructionDataArgs['logLevel'];\n  assertion: AssertStakeAccountInstructionDataArgs['assertion'];\n};\n\nexport function getAssertStakeAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertStakeAccountInputWithSigners<TAccountTargetAccount>\n): AssertStakeAccountInstructionWithSigners<TProgram, TAccountTargetAccount>;\nexport function getAssertStakeAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertStakeAccountInput<TAccountTargetAccount>\n): AssertStakeAccountInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertStakeAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertStakeAccountInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertStakeAccountInstructionRaw<TProgram, TAccountTargetAccount>\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertStakeAccountInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertStakeAccountInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertStakeAccountInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertStakeAccountInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertStakeAccountInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertStakeAccountInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertStakeAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertStakeAccountInstructionData;\n};\n\nexport function parseAssertStakeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertStakeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertStakeAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  StakeAccountAssertion,\n  StakeAccountAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getStakeAccountAssertionDecoder,\n  getStakeAccountAssertionEncoder,\n} from '../types';\n\nexport type AssertStakeAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertStakeAccountMultiInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertStakeAccountMultiInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertions: Array<StakeAccountAssertion>;\n};\n\nexport type AssertStakeAccountMultiInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertions: Array<StakeAccountAssertionArgs>;\n};\n\nexport function getAssertStakeAccountMultiInstructionDataEncoder(): Encoder<AssertStakeAccountMultiInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertions', getArrayEncoder(getStakeAccountAssertionEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 11,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertStakeAccountMultiInstructionDataDecoder(): Decoder<AssertStakeAccountMultiInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertions', getArrayDecoder(getStakeAccountAssertionDecoder())],\n  ]);\n}\n\nexport function getAssertStakeAccountMultiInstructionDataCodec(): Codec<\n  AssertStakeAccountMultiInstructionDataArgs,\n  AssertStakeAccountMultiInstructionData\n> {\n  return combineCodec(\n    getAssertStakeAccountMultiInstructionDataEncoder(),\n    getAssertStakeAccountMultiInstructionDataDecoder()\n  );\n}\n\nexport type AssertStakeAccountMultiInput<TAccountTargetAccount extends string> =\n  {\n    /** Target account to be asserted */\n    targetAccount: Address<TAccountTargetAccount>;\n    logLevel?: AssertStakeAccountMultiInstructionDataArgs['logLevel'];\n    assertions: AssertStakeAccountMultiInstructionDataArgs['assertions'];\n  };\n\nexport type AssertStakeAccountMultiInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertStakeAccountMultiInstructionDataArgs['logLevel'];\n  assertions: AssertStakeAccountMultiInstructionDataArgs['assertions'];\n};\n\nexport function getAssertStakeAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertStakeAccountMultiInputWithSigners<TAccountTargetAccount>\n): AssertStakeAccountMultiInstructionWithSigners<\n  TProgram,\n  TAccountTargetAccount\n>;\nexport function getAssertStakeAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertStakeAccountMultiInput<TAccountTargetAccount>\n): AssertStakeAccountMultiInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertStakeAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertStakeAccountMultiInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertStakeAccountMultiInstructionRaw<\n      TProgram,\n      TAccountTargetAccount\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertStakeAccountMultiInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertStakeAccountMultiInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertStakeAccountMultiInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertStakeAccountMultiInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertStakeAccountMultiInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertStakeAccountMultiInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertStakeAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertStakeAccountMultiInstructionData;\n};\n\nexport function parseAssertStakeAccountMultiInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertStakeAccountMultiInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertStakeAccountMultiInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n} from '@solana/instructions';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  SysvarClockAssertion,\n  SysvarClockAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getSysvarClockAssertionDecoder,\n  getSysvarClockAssertionEncoder,\n} from '../types';\n\nexport type AssertSysvarClockInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type AssertSysvarClockInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type AssertSysvarClockInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: SysvarClockAssertion;\n};\n\nexport type AssertSysvarClockInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: SysvarClockAssertionArgs;\n};\n\nexport function getAssertSysvarClockInstructionDataEncoder(): Encoder<AssertSysvarClockInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getSysvarClockAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 14,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertSysvarClockInstructionDataDecoder(): Decoder<AssertSysvarClockInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getSysvarClockAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertSysvarClockInstructionDataCodec(): Codec<\n  AssertSysvarClockInstructionDataArgs,\n  AssertSysvarClockInstructionData\n> {\n  return combineCodec(\n    getAssertSysvarClockInstructionDataEncoder(),\n    getAssertSysvarClockInstructionDataDecoder()\n  );\n}\n\nexport type AssertSysvarClockInput = {\n  logLevel?: AssertSysvarClockInstructionDataArgs['logLevel'];\n  assertion: AssertSysvarClockInstructionDataArgs['assertion'];\n};\n\nexport type AssertSysvarClockInputWithSigners = {\n  logLevel?: AssertSysvarClockInstructionDataArgs['logLevel'];\n  assertion: AssertSysvarClockInstructionDataArgs['assertion'];\n};\n\nexport function getAssertSysvarClockInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertSysvarClockInputWithSigners\n): AssertSysvarClockInstructionWithSigners<TProgram>;\nexport function getAssertSysvarClockInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertSysvarClockInput): AssertSysvarClockInstruction<TProgram>;\nexport function getAssertSysvarClockInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertSysvarClockInput): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = getAssertSysvarClockInstructionRaw(\n    args as AssertSysvarClockInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertSysvarClockInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  args: AssertSysvarClockInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: remainingAccounts ?? [],\n    data: getAssertSysvarClockInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertSysvarClockInstruction<TProgram, TRemainingAccounts>;\n}\n\nexport type ParsedAssertSysvarClockInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n> = {\n  programAddress: Address<TProgram>;\n  data: AssertSysvarClockInstructionData;\n};\n\nexport function parseAssertSysvarClockInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedAssertSysvarClockInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getAssertSysvarClockInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  TokenAccountAssertion,\n  TokenAccountAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getTokenAccountAssertionDecoder,\n  getTokenAccountAssertionEncoder,\n} from '../types';\n\nexport type AssertTokenAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertTokenAccountInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertTokenAccountInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: TokenAccountAssertion;\n};\n\nexport type AssertTokenAccountInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: TokenAccountAssertionArgs;\n};\n\nexport function getAssertTokenAccountInstructionDataEncoder(): Encoder<AssertTokenAccountInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getTokenAccountAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 8,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertTokenAccountInstructionDataDecoder(): Decoder<AssertTokenAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getTokenAccountAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertTokenAccountInstructionDataCodec(): Codec<\n  AssertTokenAccountInstructionDataArgs,\n  AssertTokenAccountInstructionData\n> {\n  return combineCodec(\n    getAssertTokenAccountInstructionDataEncoder(),\n    getAssertTokenAccountInstructionDataDecoder()\n  );\n}\n\nexport type AssertTokenAccountInput<TAccountTargetAccount extends string> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertTokenAccountInstructionDataArgs['logLevel'];\n  assertion: AssertTokenAccountInstructionDataArgs['assertion'];\n};\n\nexport type AssertTokenAccountInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertTokenAccountInstructionDataArgs['logLevel'];\n  assertion: AssertTokenAccountInstructionDataArgs['assertion'];\n};\n\nexport function getAssertTokenAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertTokenAccountInputWithSigners<TAccountTargetAccount>\n): AssertTokenAccountInstructionWithSigners<TProgram, TAccountTargetAccount>;\nexport function getAssertTokenAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertTokenAccountInput<TAccountTargetAccount>\n): AssertTokenAccountInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertTokenAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertTokenAccountInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertTokenAccountInstructionRaw<TProgram, TAccountTargetAccount>\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertTokenAccountInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertTokenAccountInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertTokenAccountInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertTokenAccountInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertTokenAccountInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertTokenAccountInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertTokenAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertTokenAccountInstructionData;\n};\n\nexport function parseAssertTokenAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertTokenAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertTokenAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  TokenAccountAssertion,\n  TokenAccountAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getTokenAccountAssertionDecoder,\n  getTokenAccountAssertionEncoder,\n} from '../types';\n\nexport type AssertTokenAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertTokenAccountMultiInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertTokenAccountMultiInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertions: Array<TokenAccountAssertion>;\n};\n\nexport type AssertTokenAccountMultiInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertions: Array<TokenAccountAssertionArgs>;\n};\n\nexport function getAssertTokenAccountMultiInstructionDataEncoder(): Encoder<AssertTokenAccountMultiInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertions', getArrayEncoder(getTokenAccountAssertionEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 9,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertTokenAccountMultiInstructionDataDecoder(): Decoder<AssertTokenAccountMultiInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertions', getArrayDecoder(getTokenAccountAssertionDecoder())],\n  ]);\n}\n\nexport function getAssertTokenAccountMultiInstructionDataCodec(): Codec<\n  AssertTokenAccountMultiInstructionDataArgs,\n  AssertTokenAccountMultiInstructionData\n> {\n  return combineCodec(\n    getAssertTokenAccountMultiInstructionDataEncoder(),\n    getAssertTokenAccountMultiInstructionDataDecoder()\n  );\n}\n\nexport type AssertTokenAccountMultiInput<TAccountTargetAccount extends string> =\n  {\n    /** Target account to be asserted */\n    targetAccount: Address<TAccountTargetAccount>;\n    logLevel?: AssertTokenAccountMultiInstructionDataArgs['logLevel'];\n    assertions: AssertTokenAccountMultiInstructionDataArgs['assertions'];\n  };\n\nexport type AssertTokenAccountMultiInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertTokenAccountMultiInstructionDataArgs['logLevel'];\n  assertions: AssertTokenAccountMultiInstructionDataArgs['assertions'];\n};\n\nexport function getAssertTokenAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertTokenAccountMultiInputWithSigners<TAccountTargetAccount>\n): AssertTokenAccountMultiInstructionWithSigners<\n  TProgram,\n  TAccountTargetAccount\n>;\nexport function getAssertTokenAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertTokenAccountMultiInput<TAccountTargetAccount>\n): AssertTokenAccountMultiInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertTokenAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(input: AssertTokenAccountMultiInput<TAccountTargetAccount>): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertTokenAccountMultiInstructionRaw<\n      TProgram,\n      TAccountTargetAccount\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertTokenAccountMultiInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertTokenAccountMultiInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertTokenAccountMultiInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertTokenAccountMultiInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertTokenAccountMultiInstructionDataEncoder().encode(args),\n    programAddress,\n  } as AssertTokenAccountMultiInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertTokenAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertTokenAccountMultiInstructionData;\n};\n\nexport function parseAssertTokenAccountMultiInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertTokenAccountMultiInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertTokenAccountMultiInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  UpgradeableLoaderStateAssertion,\n  UpgradeableLoaderStateAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getUpgradeableLoaderStateAssertionDecoder,\n  getUpgradeableLoaderStateAssertionEncoder,\n} from '../types';\n\nexport type AssertUpgradeableLoaderAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertUpgradeableLoaderAccountInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertUpgradeableLoaderAccountInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertion: UpgradeableLoaderStateAssertion;\n};\n\nexport type AssertUpgradeableLoaderAccountInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertion: UpgradeableLoaderStateAssertionArgs;\n};\n\nexport function getAssertUpgradeableLoaderAccountInstructionDataEncoder(): Encoder<AssertUpgradeableLoaderAccountInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      ['assertion', getUpgradeableLoaderStateAssertionEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 12,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertUpgradeableLoaderAccountInstructionDataDecoder(): Decoder<AssertUpgradeableLoaderAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    ['assertion', getUpgradeableLoaderStateAssertionDecoder()],\n  ]);\n}\n\nexport function getAssertUpgradeableLoaderAccountInstructionDataCodec(): Codec<\n  AssertUpgradeableLoaderAccountInstructionDataArgs,\n  AssertUpgradeableLoaderAccountInstructionData\n> {\n  return combineCodec(\n    getAssertUpgradeableLoaderAccountInstructionDataEncoder(),\n    getAssertUpgradeableLoaderAccountInstructionDataDecoder()\n  );\n}\n\nexport type AssertUpgradeableLoaderAccountInput<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertUpgradeableLoaderAccountInstructionDataArgs['logLevel'];\n  assertion: AssertUpgradeableLoaderAccountInstructionDataArgs['assertion'];\n};\n\nexport type AssertUpgradeableLoaderAccountInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertUpgradeableLoaderAccountInstructionDataArgs['logLevel'];\n  assertion: AssertUpgradeableLoaderAccountInstructionDataArgs['assertion'];\n};\n\nexport function getAssertUpgradeableLoaderAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertUpgradeableLoaderAccountInputWithSigners<TAccountTargetAccount>\n): AssertUpgradeableLoaderAccountInstructionWithSigners<\n  TProgram,\n  TAccountTargetAccount\n>;\nexport function getAssertUpgradeableLoaderAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertUpgradeableLoaderAccountInput<TAccountTargetAccount>\n): AssertUpgradeableLoaderAccountInstruction<TProgram, TAccountTargetAccount>;\nexport function getAssertUpgradeableLoaderAccountInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertUpgradeableLoaderAccountInput<TAccountTargetAccount>\n): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertUpgradeableLoaderAccountInstructionRaw<\n      TProgram,\n      TAccountTargetAccount\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertUpgradeableLoaderAccountInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertUpgradeableLoaderAccountInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertUpgradeableLoaderAccountInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertUpgradeableLoaderAccountInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertUpgradeableLoaderAccountInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress,\n  } as AssertUpgradeableLoaderAccountInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertUpgradeableLoaderAccountInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertUpgradeableLoaderAccountInstructionData;\n};\n\nexport function parseAssertUpgradeableLoaderAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertUpgradeableLoaderAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertUpgradeableLoaderAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n} from '@solana/instructions';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  LogLevel,\n  LogLevelArgs,\n  UpgradeableLoaderStateAssertion,\n  UpgradeableLoaderStateAssertionArgs,\n  getLogLevelDecoder,\n  getLogLevelEncoder,\n  getUpgradeableLoaderStateAssertionDecoder,\n  getUpgradeableLoaderStateAssertionEncoder,\n} from '../types';\n\nexport type AssertUpgradeableLoaderAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertUpgradeableLoaderAccountMultiInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTargetAccount extends string\n        ? ReadonlyAccount<TAccountTargetAccount>\n        : TAccountTargetAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type AssertUpgradeableLoaderAccountMultiInstructionData = {\n  discriminator: number;\n  logLevel: LogLevel;\n  assertions: Array<UpgradeableLoaderStateAssertion>;\n};\n\nexport type AssertUpgradeableLoaderAccountMultiInstructionDataArgs = {\n  logLevel?: LogLevelArgs;\n  assertions: Array<UpgradeableLoaderStateAssertionArgs>;\n};\n\nexport function getAssertUpgradeableLoaderAccountMultiInstructionDataEncoder(): Encoder<AssertUpgradeableLoaderAccountMultiInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['logLevel', getLogLevelEncoder()],\n      [\n        'assertions',\n        getArrayEncoder(getUpgradeableLoaderStateAssertionEncoder()),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: 13,\n      logLevel: value.logLevel ?? LogLevel.Silent,\n    })\n  );\n}\n\nexport function getAssertUpgradeableLoaderAccountMultiInstructionDataDecoder(): Decoder<AssertUpgradeableLoaderAccountMultiInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['logLevel', getLogLevelDecoder()],\n    [\n      'assertions',\n      getArrayDecoder(getUpgradeableLoaderStateAssertionDecoder()),\n    ],\n  ]);\n}\n\nexport function getAssertUpgradeableLoaderAccountMultiInstructionDataCodec(): Codec<\n  AssertUpgradeableLoaderAccountMultiInstructionDataArgs,\n  AssertUpgradeableLoaderAccountMultiInstructionData\n> {\n  return combineCodec(\n    getAssertUpgradeableLoaderAccountMultiInstructionDataEncoder(),\n    getAssertUpgradeableLoaderAccountMultiInstructionDataDecoder()\n  );\n}\n\nexport type AssertUpgradeableLoaderAccountMultiInput<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertUpgradeableLoaderAccountMultiInstructionDataArgs['logLevel'];\n  assertions: AssertUpgradeableLoaderAccountMultiInstructionDataArgs['assertions'];\n};\n\nexport type AssertUpgradeableLoaderAccountMultiInputWithSigners<\n  TAccountTargetAccount extends string\n> = {\n  /** Target account to be asserted */\n  targetAccount: Address<TAccountTargetAccount>;\n  logLevel?: AssertUpgradeableLoaderAccountMultiInstructionDataArgs['logLevel'];\n  assertions: AssertUpgradeableLoaderAccountMultiInstructionDataArgs['assertions'];\n};\n\nexport function getAssertUpgradeableLoaderAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertUpgradeableLoaderAccountMultiInputWithSigners<TAccountTargetAccount>\n): AssertUpgradeableLoaderAccountMultiInstructionWithSigners<\n  TProgram,\n  TAccountTargetAccount\n>;\nexport function getAssertUpgradeableLoaderAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertUpgradeableLoaderAccountMultiInput<TAccountTargetAccount>\n): AssertUpgradeableLoaderAccountMultiInstruction<\n  TProgram,\n  TAccountTargetAccount\n>;\nexport function getAssertUpgradeableLoaderAccountMultiInstruction<\n  TAccountTargetAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: AssertUpgradeableLoaderAccountMultiInput<TAccountTargetAccount>\n): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getAssertUpgradeableLoaderAccountMultiInstructionRaw<\n      TProgram,\n      TAccountTargetAccount\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    targetAccount: { value: input.targetAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getAssertUpgradeableLoaderAccountMultiInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as AssertUpgradeableLoaderAccountMultiInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getAssertUpgradeableLoaderAccountMultiInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountTargetAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    targetAccount: TAccountTargetAccount extends string\n      ? Address<TAccountTargetAccount>\n      : TAccountTargetAccount;\n  },\n  args: AssertUpgradeableLoaderAccountMultiInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(accounts.targetAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getAssertUpgradeableLoaderAccountMultiInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress,\n  } as AssertUpgradeableLoaderAccountMultiInstruction<\n    TProgram,\n    TAccountTargetAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedAssertUpgradeableLoaderAccountMultiInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Target account to be asserted */\n    targetAccount: TAccountMetas[0];\n  };\n  data: AssertUpgradeableLoaderAccountMultiInstructionData;\n};\n\nexport function parseAssertUpgradeableLoaderAccountMultiInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssertUpgradeableLoaderAccountMultiInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      targetAccount: getNextAccount(),\n    },\n    data: getAssertUpgradeableLoaderAccountMultiInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  WritableAccount,\n  WritableSignerAccount,\n} from '@solana/instructions';\nimport { IAccountSignerMeta, TransactionSigner } from '@solana/signers';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\n\nexport type MemoryCloseInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountProgramId extends\n    | string\n    | IAccountMeta<string> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountMemory extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountProgramId extends string\n        ? ReadonlyAccount<TAccountProgramId>\n        : TAccountProgramId,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer>\n        : TAccountPayer,\n      TAccountMemory extends string\n        ? WritableAccount<TAccountMemory>\n        : TAccountMemory,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type MemoryCloseInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountProgramId extends\n    | string\n    | IAccountMeta<string> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountMemory extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountProgramId extends string\n        ? ReadonlyAccount<TAccountProgramId>\n        : TAccountProgramId,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountMemory extends string\n        ? WritableAccount<TAccountMemory>\n        : TAccountMemory,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type MemoryCloseInstructionData = {\n  discriminator: number;\n  memoryId: number;\n  memoryBump: number;\n};\n\nexport type MemoryCloseInstructionDataArgs = {\n  memoryId: number;\n  memoryBump: number;\n};\n\nexport function getMemoryCloseInstructionDataEncoder(): Encoder<MemoryCloseInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoryId', getU8Encoder()],\n      ['memoryBump', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: 1 })\n  );\n}\n\nexport function getMemoryCloseInstructionDataDecoder(): Decoder<MemoryCloseInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoryId', getU8Decoder()],\n    ['memoryBump', getU8Decoder()],\n  ]);\n}\n\nexport function getMemoryCloseInstructionDataCodec(): Codec<\n  MemoryCloseInstructionDataArgs,\n  MemoryCloseInstructionData\n> {\n  return combineCodec(\n    getMemoryCloseInstructionDataEncoder(),\n    getMemoryCloseInstructionDataDecoder()\n  );\n}\n\nexport type MemoryCloseInput<\n  TAccountProgramId extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string\n> = {\n  /** Lighthouse program */\n  programId?: Address<TAccountProgramId>;\n  /** Payer account */\n  payer: Address<TAccountPayer>;\n  /** Memory account */\n  memory: Address<TAccountMemory>;\n  memoryId: MemoryCloseInstructionDataArgs['memoryId'];\n  memoryBump: MemoryCloseInstructionDataArgs['memoryBump'];\n};\n\nexport type MemoryCloseInputWithSigners<\n  TAccountProgramId extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string\n> = {\n  /** Lighthouse program */\n  programId?: Address<TAccountProgramId>;\n  /** Payer account */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Memory account */\n  memory: Address<TAccountMemory>;\n  memoryId: MemoryCloseInstructionDataArgs['memoryId'];\n  memoryBump: MemoryCloseInstructionDataArgs['memoryBump'];\n};\n\nexport function getMemoryCloseInstruction<\n  TAccountProgramId extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: MemoryCloseInputWithSigners<\n    TAccountProgramId,\n    TAccountPayer,\n    TAccountMemory\n  >\n): MemoryCloseInstructionWithSigners<\n  TProgram,\n  TAccountProgramId,\n  TAccountPayer,\n  TAccountMemory\n>;\nexport function getMemoryCloseInstruction<\n  TAccountProgramId extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: MemoryCloseInput<TAccountProgramId, TAccountPayer, TAccountMemory>\n): MemoryCloseInstruction<\n  TProgram,\n  TAccountProgramId,\n  TAccountPayer,\n  TAccountMemory\n>;\nexport function getMemoryCloseInstruction<\n  TAccountProgramId extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: MemoryCloseInput<TAccountProgramId, TAccountPayer, TAccountMemory>\n): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getMemoryCloseInstructionRaw<\n      TProgram,\n      TAccountProgramId,\n      TAccountPayer,\n      TAccountMemory\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    programId: { value: input.programId ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    memory: { value: input.memory ?? null, isWritable: true },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.programId.value) {\n    accounts.programId.value = programAddress;\n    accounts.programId.isWritable = false;\n  }\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getMemoryCloseInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as MemoryCloseInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getMemoryCloseInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountProgramId extends\n    | string\n    | IAccountMeta<string> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountMemory extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    programId?: TAccountProgramId extends string\n      ? Address<TAccountProgramId>\n      : TAccountProgramId;\n    payer: TAccountPayer extends string\n      ? Address<TAccountPayer>\n      : TAccountPayer;\n    memory: TAccountMemory extends string\n      ? Address<TAccountMemory>\n      : TAccountMemory;\n  },\n  args: MemoryCloseInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(\n        accounts.programId ?? {\n          address:\n            'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>,\n          role: AccountRole.READONLY,\n        },\n        AccountRole.READONLY\n      ),\n      accountMetaWithDefault(accounts.payer, AccountRole.WRITABLE_SIGNER),\n      accountMetaWithDefault(accounts.memory, AccountRole.WRITABLE),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getMemoryCloseInstructionDataEncoder().encode(args),\n    programAddress,\n  } as MemoryCloseInstruction<\n    TProgram,\n    TAccountProgramId,\n    TAccountPayer,\n    TAccountMemory,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedMemoryCloseInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Lighthouse program */\n    programId: TAccountMetas[0];\n    /** Payer account */\n    payer: TAccountMetas[1];\n    /** Memory account */\n    memory: TAccountMetas[2];\n  };\n  data: MemoryCloseInstructionData;\n};\n\nexport function parseMemoryCloseInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMemoryCloseInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      programId: getNextAccount(),\n      payer: getNextAccount(),\n      memory: getNextAccount(),\n    },\n    data: getMemoryCloseInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  mapEncoder,\n} from '@solana/codecs';\nimport {\n  AccountRole,\n  IAccountMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  WritableAccount,\n  WritableSignerAccount,\n} from '@solana/instructions';\nimport { IAccountSignerMeta, TransactionSigner } from '@solana/signers';\nimport {\n  ResolvedAccount,\n  accountMetaWithDefault,\n  getAccountMetasWithSigners,\n} from '../shared';\nimport {\n  WriteType,\n  WriteTypeArgs,\n  getWriteTypeDecoder,\n  getWriteTypeEncoder,\n} from '../types';\n\nexport type MemoryWriteInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountProgramId extends\n    | string\n    | IAccountMeta<string> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountMemory extends string | IAccountMeta<string> = string,\n  TAccountSourceAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountProgramId extends string\n        ? ReadonlyAccount<TAccountProgramId>\n        : TAccountProgramId,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer>\n        : TAccountPayer,\n      TAccountMemory extends string\n        ? WritableAccount<TAccountMemory>\n        : TAccountMemory,\n      TAccountSourceAccount extends string\n        ? ReadonlyAccount<TAccountSourceAccount>\n        : TAccountSourceAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type MemoryWriteInstructionWithSigners<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountProgramId extends\n    | string\n    | IAccountMeta<string> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountMemory extends string | IAccountMeta<string> = string,\n  TAccountSourceAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountProgramId extends string\n        ? ReadonlyAccount<TAccountProgramId>\n        : TAccountProgramId,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountMemory extends string\n        ? WritableAccount<TAccountMemory>\n        : TAccountMemory,\n      TAccountSourceAccount extends string\n        ? ReadonlyAccount<TAccountSourceAccount>\n        : TAccountSourceAccount,\n      ...TRemainingAccounts\n    ]\n  >;\n\nexport type MemoryWriteInstructionData = {\n  discriminator: number;\n  memoryId: number;\n  memoryBump: number;\n  writeOffset: number;\n  writeType: WriteType;\n};\n\nexport type MemoryWriteInstructionDataArgs = {\n  memoryId?: number;\n  memoryBump: number;\n  writeOffset: number;\n  writeType: WriteTypeArgs;\n};\n\nexport function getMemoryWriteInstructionDataEncoder(): Encoder<MemoryWriteInstructionDataArgs> {\n  return mapEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoryId', getU8Encoder()],\n      ['memoryBump', getU8Encoder()],\n      ['writeOffset', getU16Encoder()],\n      ['writeType', getWriteTypeEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: 0, memoryId: value.memoryId ?? 0 })\n  );\n}\n\nexport function getMemoryWriteInstructionDataDecoder(): Decoder<MemoryWriteInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoryId', getU8Decoder()],\n    ['memoryBump', getU8Decoder()],\n    ['writeOffset', getU16Decoder()],\n    ['writeType', getWriteTypeDecoder()],\n  ]);\n}\n\nexport function getMemoryWriteInstructionDataCodec(): Codec<\n  MemoryWriteInstructionDataArgs,\n  MemoryWriteInstructionData\n> {\n  return combineCodec(\n    getMemoryWriteInstructionDataEncoder(),\n    getMemoryWriteInstructionDataDecoder()\n  );\n}\n\nexport type MemoryWriteInput<\n  TAccountProgramId extends string,\n  TAccountSystemProgram extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TAccountSourceAccount extends string\n> = {\n  /** Lighthouse program */\n  programId?: Address<TAccountProgramId>;\n  /** System program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** Payer account */\n  payer: Address<TAccountPayer>;\n  /** Memory account */\n  memory: Address<TAccountMemory>;\n  /** Account to be written to memory */\n  sourceAccount: Address<TAccountSourceAccount>;\n  memoryId?: MemoryWriteInstructionDataArgs['memoryId'];\n  memoryBump: MemoryWriteInstructionDataArgs['memoryBump'];\n  writeOffset: MemoryWriteInstructionDataArgs['writeOffset'];\n  writeType: MemoryWriteInstructionDataArgs['writeType'];\n};\n\nexport type MemoryWriteInputWithSigners<\n  TAccountProgramId extends string,\n  TAccountSystemProgram extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TAccountSourceAccount extends string\n> = {\n  /** Lighthouse program */\n  programId?: Address<TAccountProgramId>;\n  /** System program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** Payer account */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Memory account */\n  memory: Address<TAccountMemory>;\n  /** Account to be written to memory */\n  sourceAccount: Address<TAccountSourceAccount>;\n  memoryId?: MemoryWriteInstructionDataArgs['memoryId'];\n  memoryBump: MemoryWriteInstructionDataArgs['memoryBump'];\n  writeOffset: MemoryWriteInstructionDataArgs['writeOffset'];\n  writeType: MemoryWriteInstructionDataArgs['writeType'];\n};\n\nexport function getMemoryWriteInstruction<\n  TAccountProgramId extends string,\n  TAccountSystemProgram extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TAccountSourceAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: MemoryWriteInputWithSigners<\n    TAccountProgramId,\n    TAccountSystemProgram,\n    TAccountPayer,\n    TAccountMemory,\n    TAccountSourceAccount\n  >\n): MemoryWriteInstructionWithSigners<\n  TProgram,\n  TAccountProgramId,\n  TAccountSystemProgram,\n  TAccountPayer,\n  TAccountMemory,\n  TAccountSourceAccount\n>;\nexport function getMemoryWriteInstruction<\n  TAccountProgramId extends string,\n  TAccountSystemProgram extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TAccountSourceAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: MemoryWriteInput<\n    TAccountProgramId,\n    TAccountSystemProgram,\n    TAccountPayer,\n    TAccountMemory,\n    TAccountSourceAccount\n  >\n): MemoryWriteInstruction<\n  TProgram,\n  TAccountProgramId,\n  TAccountSystemProgram,\n  TAccountPayer,\n  TAccountMemory,\n  TAccountSourceAccount\n>;\nexport function getMemoryWriteInstruction<\n  TAccountProgramId extends string,\n  TAccountSystemProgram extends string,\n  TAccountPayer extends string,\n  TAccountMemory extends string,\n  TAccountSourceAccount extends string,\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n>(\n  input: MemoryWriteInput<\n    TAccountProgramId,\n    TAccountSystemProgram,\n    TAccountPayer,\n    TAccountMemory,\n    TAccountSourceAccount\n  >\n): IInstruction {\n  // Program address.\n  const programAddress =\n    'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\n  // Original accounts.\n  type AccountMetas = Parameters<\n    typeof getMemoryWriteInstructionRaw<\n      TProgram,\n      TAccountProgramId,\n      TAccountSystemProgram,\n      TAccountPayer,\n      TAccountMemory,\n      TAccountSourceAccount\n    >\n  >[0];\n  const accounts: Record<keyof AccountMetas, ResolvedAccount> = {\n    programId: { value: input.programId ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    memory: { value: input.memory ?? null, isWritable: true },\n    sourceAccount: { value: input.sourceAccount ?? null, isWritable: false },\n  };\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.programId.value) {\n    accounts.programId.value = programAddress;\n    accounts.programId.isWritable = false;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  // Get account metas and signers.\n  const accountMetas = getAccountMetasWithSigners(\n    accounts,\n    'programId',\n    programAddress\n  );\n\n  const instruction = getMemoryWriteInstructionRaw(\n    accountMetas as Record<keyof AccountMetas, IAccountMeta>,\n    args as MemoryWriteInstructionDataArgs,\n    programAddress\n  );\n\n  return instruction;\n}\n\nexport function getMemoryWriteInstructionRaw<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountProgramId extends\n    | string\n    | IAccountMeta<string> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountMemory extends string | IAccountMeta<string> = string,\n  TAccountSourceAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends Array<IAccountMeta<string>> = []\n>(\n  accounts: {\n    programId?: TAccountProgramId extends string\n      ? Address<TAccountProgramId>\n      : TAccountProgramId;\n    systemProgram?: TAccountSystemProgram extends string\n      ? Address<TAccountSystemProgram>\n      : TAccountSystemProgram;\n    payer: TAccountPayer extends string\n      ? Address<TAccountPayer>\n      : TAccountPayer;\n    memory: TAccountMemory extends string\n      ? Address<TAccountMemory>\n      : TAccountMemory;\n    sourceAccount: TAccountSourceAccount extends string\n      ? Address<TAccountSourceAccount>\n      : TAccountSourceAccount;\n  },\n  args: MemoryWriteInstructionDataArgs,\n  programAddress: Address<TProgram> = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<TProgram>,\n  remainingAccounts?: TRemainingAccounts\n) {\n  return {\n    accounts: [\n      accountMetaWithDefault(\n        accounts.programId ?? {\n          address:\n            'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>,\n          role: AccountRole.READONLY,\n        },\n        AccountRole.READONLY\n      ),\n      accountMetaWithDefault(\n        accounts.systemProgram ??\n          ('11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>),\n        AccountRole.READONLY\n      ),\n      accountMetaWithDefault(accounts.payer, AccountRole.WRITABLE_SIGNER),\n      accountMetaWithDefault(accounts.memory, AccountRole.WRITABLE),\n      accountMetaWithDefault(accounts.sourceAccount, AccountRole.READONLY),\n      ...(remainingAccounts ?? []),\n    ],\n    data: getMemoryWriteInstructionDataEncoder().encode(args),\n    programAddress,\n  } as MemoryWriteInstruction<\n    TProgram,\n    TAccountProgramId,\n    TAccountSystemProgram,\n    TAccountPayer,\n    TAccountMemory,\n    TAccountSourceAccount,\n    TRemainingAccounts\n  >;\n}\n\nexport type ParsedMemoryWriteInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK',\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Lighthouse program */\n    programId: TAccountMetas[0];\n    /** System program */\n    systemProgram: TAccountMetas[1];\n    /** Payer account */\n    payer: TAccountMetas[2];\n    /** Memory account */\n    memory: TAccountMetas[3];\n    /** Account to be written to memory */\n    sourceAccount: TAccountMetas[4];\n  };\n  data: MemoryWriteInstructionData;\n};\n\nexport function parseMemoryWriteInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[]\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMemoryWriteInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      programId: getNextAccount(),\n      systemProgram: getNextAccount(),\n      payer: getNextAccount(),\n      memory: getNextAccount(),\n      sourceAccount: getNextAccount(),\n    },\n    data: getMemoryWriteInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport {\n  Address,\n  ProgramDerivedAddress,\n  getAddressEncoder,\n  getProgramDerivedAddress,\n} from '@solana/addresses';\nimport { getStringEncoder, getU8Encoder } from '@solana/codecs';\n\nexport type MemorySeeds = {\n  payer: Address;\n\n  memoryId: number;\n};\n\nexport async function findMemoryPda(\n  seeds: MemorySeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>,\n  } = config;\n  return getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getStringEncoder({ size: 'variable' }).encode('memory'),\n      getAddressEncoder().encode(seeds.payer),\n      getU8Encoder().encode(seeds.memoryId),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/metaplex-foundation/kinobi\n */\n\nimport { Address } from '@solana/addresses';\nimport { getU8Encoder } from '@solana/codecs';\nimport { Program, ProgramWithErrors } from '@solana/programs';\nimport {\n  LighthouseProgramError,\n  LighthouseProgramErrorCode,\n  getLighthouseProgramErrorFromCode,\n} from '../errors';\nimport {\n  ParsedAssertAccountDataInstruction,\n  ParsedAssertAccountDeltaInstruction,\n  ParsedAssertAccountInfoInstruction,\n  ParsedAssertAccountInfoMultiInstruction,\n  ParsedAssertMerkleTreeAccountInstruction,\n  ParsedAssertMintAccountInstruction,\n  ParsedAssertMintAccountMultiInstruction,\n  ParsedAssertStakeAccountInstruction,\n  ParsedAssertStakeAccountMultiInstruction,\n  ParsedAssertSysvarClockInstruction,\n  ParsedAssertTokenAccountInstruction,\n  ParsedAssertTokenAccountMultiInstruction,\n  ParsedAssertUpgradeableLoaderAccountInstruction,\n  ParsedAssertUpgradeableLoaderAccountMultiInstruction,\n  ParsedMemoryCloseInstruction,\n  ParsedMemoryWriteInstruction,\n} from '../instructions';\nimport { memcmp } from '../shared';\n\nexport const LIGHTHOUSE_PROGRAM_ADDRESS =\n  'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK' as Address<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'>;\n\nexport type LighthouseProgram =\n  Program<'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'> &\n    ProgramWithErrors<LighthouseProgramErrorCode, LighthouseProgramError>;\n\nexport function getLighthouseProgram(): LighthouseProgram {\n  return {\n    name: 'lighthouse',\n    address: LIGHTHOUSE_PROGRAM_ADDRESS,\n    getErrorFromCode(code: LighthouseProgramErrorCode, cause?: Error) {\n      return getLighthouseProgramErrorFromCode(code, cause);\n    },\n  };\n}\n\nexport enum LighthouseInstruction {\n  MemoryWrite,\n  MemoryClose,\n  AssertAccountData,\n  AssertAccountDelta,\n  AssertAccountInfo,\n  AssertAccountInfoMulti,\n  AssertMintAccount,\n  AssertMintAccountMulti,\n  AssertTokenAccount,\n  AssertTokenAccountMulti,\n  AssertStakeAccount,\n  AssertStakeAccountMulti,\n  AssertUpgradeableLoaderAccount,\n  AssertUpgradeableLoaderAccountMulti,\n  AssertSysvarClock,\n  AssertMerkleTreeAccount,\n}\n\nexport function identifyLighthouseInstruction(\n  instruction: { data: Uint8Array } | Uint8Array\n): LighthouseInstruction {\n  const data =\n    instruction instanceof Uint8Array ? instruction : instruction.data;\n  if (memcmp(data, getU8Encoder().encode(0), 0)) {\n    return LighthouseInstruction.MemoryWrite;\n  }\n  if (memcmp(data, getU8Encoder().encode(1), 0)) {\n    return LighthouseInstruction.MemoryClose;\n  }\n  if (memcmp(data, getU8Encoder().encode(2), 0)) {\n    return LighthouseInstruction.AssertAccountData;\n  }\n  if (memcmp(data, getU8Encoder().encode(3), 0)) {\n    return LighthouseInstruction.AssertAccountDelta;\n  }\n  if (memcmp(data, getU8Encoder().encode(4), 0)) {\n    return LighthouseInstruction.AssertAccountInfo;\n  }\n  if (memcmp(data, getU8Encoder().encode(5), 0)) {\n    return LighthouseInstruction.AssertAccountInfoMulti;\n  }\n  if (memcmp(data, getU8Encoder().encode(6), 0)) {\n    return LighthouseInstruction.AssertMintAccount;\n  }\n  if (memcmp(data, getU8Encoder().encode(7), 0)) {\n    return LighthouseInstruction.AssertMintAccountMulti;\n  }\n  if (memcmp(data, getU8Encoder().encode(8), 0)) {\n    return LighthouseInstruction.AssertTokenAccount;\n  }\n  if (memcmp(data, getU8Encoder().encode(9), 0)) {\n    return LighthouseInstruction.AssertTokenAccountMulti;\n  }\n  if (memcmp(data, getU8Encoder().encode(10), 0)) {\n    return LighthouseInstruction.AssertStakeAccount;\n  }\n  if (memcmp(data, getU8Encoder().encode(11), 0)) {\n    return LighthouseInstruction.AssertStakeAccountMulti;\n  }\n  if (memcmp(data, getU8Encoder().encode(12), 0)) {\n    return LighthouseInstruction.AssertUpgradeableLoaderAccount;\n  }\n  if (memcmp(data, getU8Encoder().encode(13), 0)) {\n    return LighthouseInstruction.AssertUpgradeableLoaderAccountMulti;\n  }\n  if (memcmp(data, getU8Encoder().encode(14), 0)) {\n    return LighthouseInstruction.AssertSysvarClock;\n  }\n  if (memcmp(data, getU8Encoder().encode(15), 0)) {\n    return LighthouseInstruction.AssertMerkleTreeAccount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a lighthouse instruction.'\n  );\n}\n\nexport type ParsedLighthouseInstruction<\n  TProgram extends string = 'L1TEVtgA75k273wWz1s6XMmDhQY5i3MwcvKb4VbZzfK'\n> =\n  | ({\n      instructionType: LighthouseInstruction.MemoryWrite;\n    } & ParsedMemoryWriteInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.MemoryClose;\n    } & ParsedMemoryCloseInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertAccountData;\n    } & ParsedAssertAccountDataInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertAccountDelta;\n    } & ParsedAssertAccountDeltaInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertAccountInfo;\n    } & ParsedAssertAccountInfoInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertAccountInfoMulti;\n    } & ParsedAssertAccountInfoMultiInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertMintAccount;\n    } & ParsedAssertMintAccountInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertMintAccountMulti;\n    } & ParsedAssertMintAccountMultiInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertTokenAccount;\n    } & ParsedAssertTokenAccountInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertTokenAccountMulti;\n    } & ParsedAssertTokenAccountMultiInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertStakeAccount;\n    } & ParsedAssertStakeAccountInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertStakeAccountMulti;\n    } & ParsedAssertStakeAccountMultiInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertUpgradeableLoaderAccount;\n    } & ParsedAssertUpgradeableLoaderAccountInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertUpgradeableLoaderAccountMulti;\n    } & ParsedAssertUpgradeableLoaderAccountMultiInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertSysvarClock;\n    } & ParsedAssertSysvarClockInstruction<TProgram>)\n  | ({\n      instructionType: LighthouseInstruction.AssertMerkleTreeAccount;\n    } & ParsedAssertMerkleTreeAccountInstruction<TProgram>);\n"]}